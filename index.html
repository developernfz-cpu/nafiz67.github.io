<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NAFIZ EMPIRE - Bangladeshi Open World</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', 'Kalpurush', 'Arial', sans-serif;
            background: #000;
            color: white;
            touch-action: none;
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="14" fill="%23f42a41" opacity="0.8"/><circle cx="16" cy="16" r="6" fill="%23ffffff"/></svg>') 16 16, auto;
        }

        canvas {
            display: block;
        }

        /* LOADING SCREEN - Advanced Bangladeshi Theme */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                #006a4e 0%, #00563d 25%, 
                #f42a41 25%, #d92338 50%,
                #006a4e 50%, #00563d 75%,
                #f42a41 75%, #d92338 100%);
            background-size: 400% 400%;
            animation: gradientBG 8s ease infinite;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1.2s;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .bangladeshi-flag {
            width: 300px;
            height: 180px;
            background: #006a4e;
            border-radius: 10px;
            position: relative;
            margin-bottom: 40px;
            border: 5px solid rgba(255,255,255,0.3);
            box-shadow: 
                0 20px 40px rgba(0,0,0,0.6),
                0 0 0 10px rgba(244,42,65,0.2),
                inset 0 0 30px rgba(0,0,0,0.4);
            transform-style: preserve-3d;
            perspective: 1000px;
            animation: flagFloat 6s ease-in-out infinite;
        }

        @keyframes flagFloat {
            0%, 100% { transform: translateY(0) rotateX(5deg); }
            50% { transform: translateY(-20px) rotateX(-5deg); }
        }

        .bangladeshi-flag::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background: #f42a41;
            border-radius: 50%;
            box-shadow: 
                0 0 40px rgba(244,42,65,0.8),
                inset 0 0 20px rgba(255,255,255,0.3);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        .loader {
            width: 120px;
            height: 120px;
            border: 6px solid rgba(255,255,255,0.1);
            border-top: 6px solid #f42a41;
            border-right: 6px solid #006a4e;
            border-radius: 50%;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
            box-shadow: 0 0 30px rgba(244,42,65,0.4);
        }

        #loadingText {
            font-size: 28px;
            margin-top: 10px;
            color: white;
            font-weight: bold;
            text-shadow: 3px 3px 8px rgba(0,0,0,0.7);
            background: linear-gradient(45deg, #006a4e, #f42a41, #ffd700);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: textGlow 2s ease-in-out infinite;
        }

        @keyframes textGlow {
            0%, 100% { filter: drop-shadow(0 0 10px rgba(244,42,65,0.5)); }
            50% { filter: drop-shadow(0 0 20px rgba(244,42,65,0.8)); }
        }

        .loading-progress {
            width: 400px;
            height: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            margin-top: 30px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                #006a4e 0%, 
                #00a86b 25%,
                #f42a41 50%,
                #ff6b8b 75%,
                #ffd700 100%);
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .loading-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255,255,255,0.3) 50%,
                transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* GAME CONTAINER */
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* HUD - Advanced Bangladeshi Design */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            font-family: 'Kalpurush', 'Segoe UI', sans-serif;
        }

        .hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 180px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .hud-stat {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 20px;
            padding: 15px 25px;
            backdrop-filter: blur(15px) saturate(180%);
            border: 2px solid #006a4e;
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.4),
                0 0 0 1px rgba(255,255,255,0.1),
                inset 0 0 20px rgba(0,106,78,0.3);
            min-width: 250px;
            position: relative;
            overflow: hidden;
        }

        .hud-stat::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #006a4e, #f42a41);
            border-radius: 20px 20px 0 0;
        }

        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            color: #f42a41;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        .stat-header i {
            font-size: 20px;
            margin-right: 10px;
        }

        .stat-bar-container {
            background: rgba(255,255,255,0.08);
            border-radius: 10px;
            padding: 3px;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
        }

        .stat-bar {
            width: 100%;
            height: 14px;
            background: linear-gradient(90deg, 
                rgba(0,0,0,0.3) 0%,
                rgba(0,0,0,0.1) 100%);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .stat-fill {
            height: 100%;
            border-radius: 8px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            box-shadow: 
                0 0 20px currentColor,
                inset 0 2px 4px rgba(255,255,255,0.2);
        }

        .stat-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(255,255,255,0) 0%,
                rgba(255,255,255,0.3) 50%,
                rgba(255,255,255,0) 100%);
            animation: barShine 2s infinite;
        }

        @keyframes barShine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        #healthBar { 
            background: linear-gradient(90deg, 
                #f42a41 0%,
                #ff6b6b 50%,
                #ff8e8e 100%);
            color: #f42a41;
        }
        
        #staminaBar { 
            background: linear-gradient(90deg, 
                #00a8ff 0%,
                #4cd137 50%,
                #7bed9f 100%);
            color: #00a8ff;
        }
        
        #armorBar { 
            background: linear-gradient(90deg, 
                #9b59b6 0%,
                #8e44ad 50%,
                #af7ac5 100%);
            color: #9b59b6;
        }

        .hud-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.7);
        }

        #money { 
            color: #f1c40f;
            background: linear-gradient(45deg, #f1c40f, #ffd700);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: 28px;
            text-shadow: 0 2px 10px rgba(241,196,15,0.3);
        }

        #score {
            color: #00a8ff;
            font-size: 22px;
        }

        #weaponDisplay {
            background: linear-gradient(135deg, 
                rgba(0,0,0,0.9) 0%,
                rgba(20,20,30,0.9) 100%);
            padding: 15px 30px;
            border-radius: 25px;
            border: 3px solid #f42a41;
            display: inline-flex;
            align-items: center;
            gap: 15px;
            font-size: 18px;
            font-weight: bold;
            box-shadow: 
                0 10px 30px rgba(244,42,65,0.3),
                0 0 0 2px rgba(255,255,255,0.1);
            min-width: 200px;
            backdrop-filter: blur(10px);
        }

        #weaponDisplay i {
            font-size: 24px;
            color: #f42a41;
            filter: drop-shadow(0 0 8px #f42a41);
        }

        #weaponName {
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #ammoDisplay {
            margin-left: auto;
            color: #00a8ff;
            font-size: 16px;
            background: rgba(0,168,255,0.1);
            padding: 5px 12px;
            border-radius: 12px;
            border: 1px solid rgba(0,168,255,0.3);
        }

        #locationDisplay {
            background: linear-gradient(135deg, 
                rgba(0,106,78,0.9) 0%,
                rgba(0,86,61,0.9) 100%);
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 16px;
            border: 2px solid #f42a41;
            box-shadow: 
                0 8px 25px rgba(0,106,78,0.4),
                0 0 0 1px rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 180px;
        }

        #locationDisplay i {
            color: #f42a41;
            font-size: 18px;
            filter: drop-shadow(0 0 6px #f42a41);
        }

        #locationName {
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        /* TIME DISPLAY */
        #timeDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, 
                rgba(0,0,0,0.9) 0%,
                rgba(20,20,40,0.9) 100%);
            padding: 12px 30px;
            border-radius: 25px;
            border: 2px solid #006a4e;
            font-size: 16px;
            font-weight: bold;
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 10px;
            backdrop-filter: blur(10px);
            min-width: 150px;
        }

        #timeDisplay i {
            color: #f42a41;
            font-size: 18px;
            animation: timePulse 4s infinite;
        }

        @keyframes timePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        #timeText {
            color: #00a8ff;
            text-shadow: 0 0 10px rgba(0,168,255,0.5);
        }

        /* MISSION NOTIFICATION */
        #missionNotification {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, 
                rgba(0,106,78,0.95) 0%,
                rgba(0,86,61,0.95) 100%);
            border-left: 6px solid #f42a41;
            padding: 20px 35px;
            border-radius: 20px;
            z-index: 40;
            display: none;
            backdrop-filter: blur(20px);
            animation: slideDown 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 15px 40px rgba(0,0,0,0.6),
                0 0 0 2px rgba(255,255,255,0.1);
            max-width: 500px;
            text-align: center;
            border: 2px solid #f42a41;
        }

        @keyframes slideDown {
            from { 
                transform: translateX(-50%) translateY(-100px) scale(0.9); 
                opacity: 0; 
            }
            to { 
                transform: translateX(-50%) translateY(0) scale(1); 
                opacity: 1; 
            }
        }

        #missionNotification::before {
            content: 'üì¢';
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 40px;
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.5));
            animation: bellRing 2s infinite;
        }

        @keyframes bellRing {
            0%, 100% { transform: translateX(-50%) rotate(0deg); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) rotate(-10deg); }
            20%, 40%, 60%, 80% { transform: translateX(-50%) rotate(10deg); }
        }

        #missionNotification strong {
            color: #f42a41;
            font-size: 20px;
            display: block;
            margin-bottom: 8px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        #missionNotification span {
            color: white;
            font-size: 16px;
            line-height: 1.5;
            text-shadow: 0 1px 4px rgba(0,0,0,0.5);
        }

        /* ADVANCED MOBILE CONTROLS - Bangladeshi Gaming Edition */
        #mobileControls {
            position: fixed;
            bottom: 40px;
            left: 40px;
            right: 40px;
            z-index: 20;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 25px;
            pointer-events: auto;
        }

        /* Bangladeshi Flag Themed Joystick - Advanced */
        .joystick {
            width: 160px;
            height: 160px;
            background: radial-gradient(circle at 30% 30%, 
                #006a4e 0%,
                #00563d 30%,
                #00432c 70%,
                #003020 100%);
            border-radius: 50%;
            position: relative;
            border: 6px solid #f42a41;
            box-shadow: 
                0 15px 40px rgba(0,0,0,0.6),
                0 0 0 3px rgba(255,255,255,0.2),
                inset 0 0 40px rgba(0,0,0,0.5),
                0 0 60px rgba(244,42,65,0.3);
            transform-style: preserve-3d;
            perspective: 500px;
        }

        .joystick::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 40% 40%,
                #f42a41 0%,
                #d92338 50%,
                #b81c2f 100%);
            border-radius: 50%;
            z-index: 1;
            box-shadow: 
                0 0 40px rgba(244,42,65,0.8),
                inset 0 5px 20px rgba(255,255,255,0.4);
            animation: innerPulse 3s infinite;
        }

        @keyframes innerPulse {
            0%, 100% { box-shadow: 0 0 40px rgba(244,42,65,0.8); }
            50% { box-shadow: 0 0 60px rgba(244,42,65,1); }
        }

        .joystick-handle {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 40% 40%,
                #ffffff 0%,
                #e0e0e0 30%,
                #c0c0c0 70%,
                #a0a0a0 100%);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 5px solid #f42a41;
            box-shadow: 
                0 0 40px rgba(244,42,65,0.6),
                inset 0 8px 30px rgba(255,255,255,0.9),
                0 10px 30px rgba(0,0,0,0.4);
            z-index: 2;
            transition: all 0.1s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: move;
        }

        /* Premium Action Buttons */
        .action-button {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            color: white;
            font-size: 34px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 12px 35px rgba(0,0,0,0.5),
                0 0 0 4px rgba(255,255,255,0.15),
                inset 0 0 30px rgba(255,255,255,0.1);
            transform-style: preserve-3d;
            perspective: 500px;
        }

        .action-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 30% 30%,
                rgba(255,255,255,0.3) 0%,
                rgba(255,255,255,0.1) 40%,
                transparent 70%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .action-button::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: inherit;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.5;
            z-index: -1;
            animation: buttonGlow 3s infinite;
        }

        @keyframes buttonGlow {
            0%, 100% { opacity: 0.5; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.05); }
        }

        .action-button:active {
            transform: scale(0.85) translateZ(-20px);
            box-shadow: 
                0 6px 20px rgba(0,0,0,0.4),
                0 0 0 3px rgba(255,255,255,0.2),
                inset 0 0 40px rgba(0,0,0,0.3);
        }

        .action-button:active::before {
            opacity: 1;
        }

        .action-button i {
            position: relative;
            z-index: 2;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
            transition: transform 0.2s;
        }

        .action-button:active i {
            transform: scale(1.2);
        }

        /* Individual Premium Button Themes */
        #jumpBtn { 
            background: linear-gradient(135deg, 
                #27ae60 0%,
                #2ecc71 25%,
                #4cd137 50%,
                #7bed9f 75%,
                #55efc4 100%);
            border: 5px solid #2ecc71;
        }
        
        #attackBtn { 
            background: linear-gradient(135deg, 
                #c0392b 0%,
                #e74c3c 25%,
                #ff6b6b 50%,
                #ff8e8e 75%,
                #ffafaf 100%);
            border: 5px solid #ff0000;
            animation: attackPulse 1.5s infinite;
        }
        
        @keyframes attackPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            50% { box-shadow: 0 0 0 25px rgba(231, 76, 60, 0); }
        }
        
        #interactBtn { 
            background: linear-gradient(135deg, 
                #2980b9 0%,
                #3498db 25%,
                #00a8ff 50%,
                #74b9ff 75%,
                #a29bfe 100%);
            border: 5px solid #3498db;
        }
        
        #menuBtn { 
            background: linear-gradient(135deg, 
                #8e44ad 0%,
                #9b59b6 25%,
                #a29bfe 50%,
                #c8a2c8 75%,
                #d6a2e8 100%);
            border: 5px solid #9b59b6;
        }

        #weaponBtn {
            background: linear-gradient(135deg, 
                #e67e22 0%,
                #f39c12 25%,
                #fdcb6e 50%,
                #ffeaa7 75%,
                #ffeb3b 100%);
            border: 5px solid #f39c12;
            width: 100px;
            height: 100px;
            font-size: 38px;
        }

        #runBtn {
            background: linear-gradient(135deg, 
                #00b894 0%,
                #00cec9 25%,
                #81ecec 50%,
                #a3f7bf 75%,
                #55efc4 100%);
            border: 5px solid #00cec9;
            width: 90px;
            height: 90px;
        }

        /* First Person Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: difference;
        }

        .crosshair-dot {
            width: 8px;
            height: 8px;
            background: #f42a41;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 20px #f42a41,
                0 0 40px rgba(244,42,65,0.5),
                inset 0 0 10px rgba(255,255,255,0.3);
            animation: crosshairPulse 2s infinite;
        }

        @keyframes crosshairPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .crosshair-line {
            position: absolute;
            background: #f42a41;
            border-radius: 2px;
            box-shadow: 0 0 10px #f42a41;
        }

        .crosshair-horizontal {
            width: 20px;
            height: 4px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(90deg,
                transparent 0%,
                #f42a41 20%,
                #f42a41 80%,
                transparent 100%);
        }

        .crosshair-vertical {
            width: 4px;
            height: 20px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(0deg,
                transparent 0%,
                #f42a41 20%,
                #f42a41 80%,
                transparent 100%);
        }

        /* MINIMAP - Advanced Design */
        #miniMap {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 220px;
            height: 220px;
            background: linear-gradient(135deg, 
                rgba(0,0,0,0.9) 0%,
                rgba(20,30,40,0.9) 100%);
            border-radius: 25px;
            border: 4px solid #006a4e;
            z-index: 15;
            overflow: hidden;
            box-shadow: 
                0 15px 40px rgba(0,0,0,0.6),
                0 0 0 2px rgba(255,255,255,0.1),
                inset 0 0 30px rgba(0,106,78,0.3);
            backdrop-filter: blur(10px);
        }

        .mini-map-header {
            background: linear-gradient(90deg, #006a4e, #f42a41);
            padding: 10px 15px;
            font-weight: bold;
            text-align: center;
            color: white;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }

        .mini-map-content {
            width: 100%;
            height: calc(100% - 40px);
            position: relative;
            background: rgba(0,50,30,0.3);
        }

        .mini-map-player {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f42a41;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 0 15px #f42a41,
                0 0 30px rgba(244,42,65,0.5),
                inset 0 0 10px rgba(255,255,255,0.5);
            border: 2px solid white;
            z-index: 10;
            animation: playerBlip 2s infinite;
        }

        @keyframes playerBlip {
            0%, 100% { box-shadow: 0 0 15px #f42a41; }
            50% { box-shadow: 0 0 25px #f42a41, 0 0 40px rgba(244,42,65,0.7); }
        }

        .mini-map-npc {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #3498db;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid white;
        }

        .mini-map-vehicle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #f1c40f;
            border-radius: 2px;
            transform: translate(-50%, -50%) rotate(45deg);
            border: 1px solid white;
        }

        /* Premium Hit Effect */
        .hit-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 25;
            opacity: 0;
            transition: opacity 0.15s;
            mix-blend-mode: screen;
        }

        .hit-effect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, 
                rgba(244,42,65,0) 0%,
                rgba(244,42,65,0.4) 40%,
                rgba(244,42,65,0.2) 70%,
                transparent 100%);
        }

        .hit-effect::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.8) 0%,
                rgba(255,255,255,0) 70%);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            animation: hitFlash 0.3s;
        }

        @keyframes hitFlash {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* MENUS - Premium Design */
        .menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center,
                rgba(0,106,78,0.95) 0%,
                rgba(0,86,61,0.95) 40%,
                rgba(0,66,47,0.95) 100%);
            z-index: 30;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(30px);
            animation: menuFade 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes menuFade {
            from { opacity: 0; transform: scale(1.1); }
            to { opacity: 1; transform: scale(1); }
        }

        .menu-content {
            background: linear-gradient(135deg, 
                rgba(0,0,0,0.95) 0%,
                rgba(20,20,40,0.95) 100%);
            border-radius: 35px;
            padding: 50px;
            max-width: 600px;
            width: 90%;
            border: 4px solid #f42a41;
            box-shadow: 
                0 30px 80px rgba(244,42,65,0.4),
                0 0 0 2px rgba(255,255,255,0.1),
                inset 0 0 50px rgba(0,106,78,0.2);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .menu-content::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            right: -50%;
            bottom: -50%;
            background: conic-gradient(
                from 0deg,
                transparent 0%,
                rgba(244,42,65,0.1) 10%,
                transparent 20%,
                rgba(0,106,78,0.1) 30%,
                transparent 40%,
                rgba(244,42,65,0.1) 50%,
                transparent 60%,
                rgba(0,106,78,0.1) 70%,
                transparent 80%,
                rgba(244,42,65,0.1) 90%,
                transparent 100%
            );
            animation: menuRotate 20s linear infinite;
            z-index: -1;
        }

        @keyframes menuRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .menu h2 {
            color: #f42a41;
            margin-bottom: 40px;
            text-align: center;
            font-size: 48px;
            text-shadow: 
                0 0 30px rgba(244,42,65,0.8),
                0 0 60px rgba(244,42,65,0.5);
            font-weight: bold;
            background: linear-gradient(45deg, #f42a41, #ff6b6b, #ffd700);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { filter: drop-shadow(0 0 20px rgba(244,42,65,0.6)); }
            50% { filter: drop-shadow(0 0 40px rgba(244,42,65,0.9)); }
        }

        .menu-button {
            width: 100%;
            padding: 22px;
            margin: 15px 0;
            background: linear-gradient(135deg, 
                rgba(0,106,78,0.8) 0%,
                rgba(0,86,61,0.8) 100%);
            border: 3px solid #f42a41;
            color: white;
            border-radius: 20px;
            font-size: 22px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            position: relative;
            overflow: hidden;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }

        .menu-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255,255,255,0.2) 50%,
                transparent 100%);
            transition: left 0.6s;
        }

        .menu-button:hover {
            background: linear-gradient(135deg, 
                rgba(0,135,90,0.9) 0%,
                rgba(0,106,78,0.9) 100%);
            transform: translateY(-5px) scale(1.02);
            box-shadow: 
                0 15px 35px rgba(244,42,65,0.4),
                0 0 0 2px rgba(255,255,255,0.2);
        }

        .menu-button:hover::before {
            left: 100%;
        }

        .menu-button:active {
            transform: translateY(0) scale(0.98);
        }

        .menu-button i {
            font-size: 26px;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.5));
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 768px) {
            .joystick {
                width: 130px;
                height: 130px;
            }
            
            .action-button {
                width: 75px;
                height: 75px;
                font-size: 28px;
            }
            
            #weaponBtn {
                width: 80px;
                height: 80px;
                font-size: 32px;
            }
            
            #runBtn {
                width: 75px;
                height: 75px;
            }
            
            .hud-stat {
                padding: 12px 20px;
                font-size: 14px;
                min-width: 200px;
            }
            
            #miniMap {
                width: 170px;
                height: 170px;
                bottom: 30px;
                right: 30px;
            }
            
            .menu-content {
                padding: 30px;
            }
            
            .menu h2 {
                font-size: 36px;
            }
            
            .menu-button {
                padding: 18px;
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            .hud-top-left, .hud-top-right {
                transform: scale(0.8);
                transform-origin: top left;
            }
            
            .hud-top-right {
                transform: scale(0.8);
                transform-origin: top right;
            }
            
            #mobileControls {
                bottom: 20px;
                left: 20px;
                right: 20px;
            }
            
            .joystick {
                width: 110px;
                height: 110px;
            }
            
            .action-button {
                width: 65px;
                height: 65px;
                font-size: 24px;
            }
        }

        /* DEBUG INFO */
        #debugInfo {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: #00ff00;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
            display: none;
            border: 1px solid #00ff00;
            max-width: 300px;
        }

        /* ACHIEVEMENT POPUP */
        #achievementPopup {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, 
                rgba(0,106,78,0.95) 0%,
                rgba(0,86,61,0.95) 100%);
            padding: 20px;
            border-radius: 15px;
            border-left: 6px solid #ffd700;
            z-index: 35;
            display: none;
            animation: slideInRight 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            min-width: 250px;
            backdrop-filter: blur(10px);
        }

        @keyframes slideInRight {
            from { transform: translateX(100%) translateY(-50%); opacity: 0; }
            to { transform: translateX(0) translateY(-50%); opacity: 1; }
        }

        #achievementPopup i {
            color: #ffd700;
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
            animation: achievementIcon 2s infinite;
        }

        @keyframes achievementIcon {
            0%, 100% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.1) rotate(-10deg); }
            75% { transform: scale(1.1) rotate(10deg); }
        }

        /* LOADING TIPS */
        #loadingTips {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 18px;
            max-width: 600px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.7);
            opacity: 0.8;
            animation: tipFade 8s infinite;
        }

        @keyframes tipFade {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }

        /* BLOOM EFFECT */
        .bloom-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            mix-blend-mode: screen;
            opacity: 0.3;
            filter: blur(20px);
            background: radial-gradient(circle at 50% 50%, 
                rgba(244,42,65,0.3) 0%,
                rgba(0,106,78,0.2) 30%,
                transparent 70%);
        }

        /* FOG EFFECT */
        .fog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 50% 50%, 
                transparent 0%,
                rgba(0,106,78,0.1) 40%,
                rgba(0,86,61,0.2) 100%);
            pointer-events: none;
            z-index: 4;
            animation: fogMove 30s linear infinite;
        }

        @keyframes fogMove {
            0% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(50px, 50px) scale(1.1); }
            100% { transform: translate(0, 0) scale(1); }
        }
    </style>
</head>
<body>
    <!-- ADVANCED LOADING SCREEN -->
    <div id="loadingScreen">
        <div class="bangladeshi-flag"></div>
        <div class="loader"></div>
        <h2 style="font-size: 48px; margin-bottom: 15px; color: white; text-shadow: 4px 4px 12px rgba(0,0,0,0.8);">NAFIZ EMPIRE</h2>
        <p style="color: #ffd700; margin-bottom: 30px; font-size: 22px; font-weight: bold; text-shadow: 0 2px 8px rgba(0,0,0,0.7);">
            üáßüá© ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶ì‡¶™‡ßá‡¶® ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶≤‡ßç‡¶° ‡¶ó‡ßá‡¶Æ‡¶ø‡¶Ç ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏ üáßüá©
        </p>
        <div id="loadingText">‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡¶ø‡¶ï‡ßç‡¶∏ ‡¶á‡¶û‡ßç‡¶ú‡¶ø‡¶® ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...</div>
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
        <div id="loadingTips">
            üí° ‡¶ü‡¶ø‡¶™: ‡¶∂‡¶π‡¶∞‡ßá ‡¶ò‡ßÅ‡¶∞‡ßá ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶Æ‡¶ø‡¶∂‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ó‡ßã‡¶™‡¶® ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ ‡¶Ü‡¶¨‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®!
        </div>
        <div style="position: absolute; bottom: 30px; color: rgba(255,255,255,0.5); font-size: 14px;">
            Powered by Three.js ‚Ä¢ Optimized for Mobile & PC ‚Ä¢ Made with ‚ù§Ô∏è for Bangladesh
        </div>
    </div>

    <!-- GAME CONTAINER -->
    <div id="gameContainer"></div>

    <!-- VISUAL EFFECTS -->
    <div class="bloom-layer"></div>
    <div class="fog-overlay"></div>

    <!-- ADVANCED HUD -->
    <div id="hud">
        <!-- First Person Crosshair -->
        <div id="crosshair">
            <div class="crosshair-dot"></div>
            <div class="crosshair-line crosshair-horizontal"></div>
            <div class="crosshair-line crosshair-vertical"></div>
        </div>

        <!-- Top Left HUD -->
        <div class="hud-top-left">
            <div class="hud-stat">
                <div class="stat-header">
                    <span><i class="fas fa-heart-pulse"></i> ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø</span>
                    <span id="healthValue">100%</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-bar">
                        <div id="healthBar" class="stat-fill" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="hud-stat">
                <div class="stat-header">
                    <span><i class="fas fa-bolt-lightning"></i> ‡¶∂‡¶ï‡ßç‡¶§‡¶ø</span>
                    <span id="staminaValue">100%</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-bar">
                        <div id="staminaBar" class="stat-fill" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="hud-stat">
                <div class="stat-header">
                    <span><i class="fas fa-shield-halved"></i> ‡¶Ü‡¶∞‡ßç‡¶Æ‡¶æ‡¶∞</span>
                    <span id="armorValue">0%</span>
                </div>
                <div class="stat-bar-container">
                    <div class="stat-bar">
                        <div id="armorBar" class="stat-fill" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Top Right HUD -->
        <div class="hud-top-right">
            <div id="weaponDisplay">
                <i class="fas fa-gun"></i>
                <span id="weaponName">‡¶è‡¶Æ-‡ßß‡ß¨ ‡¶∞‡¶æ‡¶á‡¶´‡ßá‡¶≤</span>
                <div id="ammoDisplay">
                    <i class="fas fa-bullseye"></i> <span id="ammoCount">30/120</span>
                </div>
            </div>
            
            <div id="locationDisplay">
                <i class="fas fa-location-crosshairs"></i>
                <span id="locationName">‡¶¢‡¶æ‡¶ï‡¶æ ‡¶∏‡ßá‡¶®‡¶æ‡¶®‡¶ø‡¶¨‡¶æ‡¶∏</span>
            </div>
            
            <div class="hud-stat" style="min-width: 200px;">
                <div class="stat-header">
                    <span><i class="fas fa-money-bill-wave"></i> ‡¶ü‡¶æ‡¶ï‡¶æ</span>
                </div>
                <div class="hud-value" id="money">‡ß≥ ‡ßß‡ß¶,‡ß¶‡ß¶‡ß¶</div>
            </div>
            
            <div class="hud-stat" style="min-width: 180px;">
                <div class="stat-header">
                    <span><i class="fas fa-trophy"></i> ‡¶∏‡ßç‡¶ï‡ßã‡¶∞</span>
                </div>
                <div class="hud-value" id="score">‡ß®,‡ß´‡ß¶‡ß¶</div>
            </div>
        </div>

        <!-- Time Display -->
        <div id="timeDisplay">
            <i class="fas fa-sun"></i>
            <span id="timeText">‡¶∏‡¶ï‡¶æ‡¶≤ ‡ßß‡ßß:‡ß©‡ß¶</span>
        </div>

        <!-- Mission Notification -->
        <div id="missionNotification">
            <strong>‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡¶ø‡¶∂‡¶®!</strong>
            <span id="missionText">‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶®‡¶Æ‡¶®‡ßç‡¶§‡ßç‡¶∞‡ßÄ‡¶∞ ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶æ‡¶≤‡¶Ø‡¶º‡ßá‡¶∞ ‡¶®‡¶ø‡¶∞‡¶æ‡¶™‡¶§‡ßç‡¶§‡¶æ ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®</span>
        </div>

        <!-- Hit Effect -->
        <div class="hit-effect" id="hitEffect"></div>

        <!-- Achievement Popup -->
        <div id="achievementPopup">
            <i class="fas fa-trophy"></i>
            <strong style="color: #ffd700; display: block; margin-bottom: 5px;">‡¶Ö‡¶∞‡ßç‡¶ú‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®!</strong>
            <span id="achievementText">‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶ï‡ßá‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø</span>
        </div>

        <!-- Minimap -->
        <div id="miniMap">
            <div class="mini-map-header">
                <i class="fas fa-map"></i> ‡¶Æ‡¶ø‡¶®‡¶ø ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™
            </div>
            <div class="mini-map-content" id="miniMapContent">
                <div class="mini-map-player"></div>
            </div>
        </div>
    </div>

    <!-- PREMIUM MOBILE CONTROLS -->
    <div id="mobileControls">
        <div class="control-group">
            <div class="joystick" id="moveJoystick">
                <div class="joystick-handle"></div>
            </div>
            <div class="action-button" id="jumpBtn">
                <i class="fas fa-up-long"></i>
            </div>
            <div class="action-button" id="runBtn">
                <i class="fas fa-person-running"></i>
            </div>
        </div>
        
        <div class="control-group">
            <div class="action-button" id="weaponBtn">
                <i class="fas fa-repeat"></i>
            </div>
            <div class="action-button" id="attackBtn">
                <i class="fas fa-crosshairs"></i>
            </div>
            <div class="action-button" id="interactBtn">
                <i class="fas fa-handshake-angle"></i>
            </div>
            <div class="action-button" id="menuBtn">
                <i class="fas fa-gear"></i>
            </div>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="mainMenu" class="menu">
        <div class="menu-content">
            <h2>NAFIZ EMPIRE</h2>
            <button class="menu-button" id="resumeBtn">
                <i class="fas fa-play-circle"></i> ‡¶ó‡ßá‡¶Æ ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶®
            </button>
            <button class="menu-button" id="newGameBtn">
                <i class="fas fa-rocket"></i> ‡¶®‡¶§‡ßÅ‡¶® ‡¶Ö‡¶≠‡¶ø‡¶Ø‡¶æ‡¶® ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
            <button class="menu-button" id="loadGameBtn">
                <i class="fas fa-folder-open"></i> ‡¶∏‡ßá‡¶≠ ‡¶ó‡ßá‡¶Æ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
            <button class="menu-button" id="settingsBtn">
                <i class="fas fa-sliders"></i> ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏
            </button>
            <button class="menu-button" id="missionsBtn">
                <i class="fas fa-flag-checkered"></i> ‡¶Æ‡¶ø‡¶∂‡¶® ‡¶ó‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶∞‡¶ø
            </button>
            <button class="menu-button" id="inventoryBtn">
                <i class="fas fa-warehouse"></i> ‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø
            </button>
            <button class="menu-button" id="helpBtn">
                <i class="fas fa-graduation-cap"></i> ‡¶ü‡ßç‡¶∞‡ßá‡¶®‡¶ø‡¶Ç ‡¶Æ‡ßã‡¶°
            </button>
        </div>
    </div>

    <!-- SETTINGS MENU -->
    <div id="settingsMenu" class="menu">
        <div class="menu-content">
            <h2><i class="fas fa-sliders"></i> ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏</h2>
            <button class="menu-button" id="backBtn">
                <i class="fas fa-arrow-left-long"></i> ‡¶™‡ßç‡¶∞‡¶ß‡¶æ‡¶® ‡¶Æ‡ßá‡¶®‡ßÅ
            </button>
            
            <div style="margin: 30px 0; color: #f42a41; text-align: left;">
                <div style="margin: 20px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 20px; color: #00a8ff;">
                        <i class="fas fa-display"></i> ‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡¶ø‡¶ï‡ßç‡¶∏ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏
                    </label>
                    <select id="graphicsQuality" style="width: 100%; padding: 15px; background: #111; color: white; border: 2px solid #006a4e; border-radius: 12px; font-size: 18px; margin-bottom: 15px;">
                        <option value="low">‡¶≤‡ßã (‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶Ö‡¶™‡¶ü‡¶ø‡¶Æ‡¶æ‡¶á‡¶ú‡¶°)</option>
                        <option value="medium" selected>‡¶Æ‡¶ø‡¶°‡¶ø‡¶Ø‡¶º‡¶æ‡¶Æ (‡¶¨‡ßç‡¶Ø‡¶æ‡¶≤‡ßá‡¶®‡ßç‡¶∏‡¶°)</option>
                        <option value="high">‡¶π‡¶æ‡¶á (‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§)</option>
                        <option value="ultra">‡¶Ü‡¶≤‡ßç‡¶ü‡ßç‡¶∞‡¶æ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶°‡¶ø‡¶ü‡ßá‡¶á‡¶≤)</option>
                    </select>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-size: 16px;">‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ö‡¶æ‡¶∞ ‡¶ï‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø</label>
                            <select style="width: 100%; padding: 12px; background: #222; color: white; border: 1px solid #006a4e; border-radius: 8px;">
                                <option>‡¶≤‡ßã</option>
                                <option selected>‡¶Æ‡¶ø‡¶°‡¶ø‡¶Ø‡¶º‡¶æ‡¶Æ</option>
                                <option>‡¶π‡¶æ‡¶á</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-size: 16px;">‡¶∂‡ßá‡¶°‡ßã ‡¶ï‡ßÅ‡¶Ø‡¶º‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø</label>
                            <select style="width: 100%; padding: 12px; background: #222; color: white; border: 1px solid #006a4e; border-radius: 8px;">
                                <option>‡¶Ö‡¶´</option>
                                <option>‡¶≤‡ßã</option>
                                <option selected>‡¶Æ‡¶ø‡¶°‡¶ø‡¶Ø‡¶º‡¶æ‡¶Æ</option>
                                <option>‡¶π‡¶æ‡¶á</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-size: 16px;">‡¶è‡¶®‡ßç‡¶ü‡¶ø-‡¶è‡¶≤‡¶ø‡¶Ø‡¶º‡¶æ‡¶∏‡¶ø‡¶Ç</label>
                            <select style="width: 100%; padding: 12px; background: #222; color: white; border: 1px solid #006a4e; border-radius: 8px;">
                                <option>‡¶Ö‡¶´</option>
                                <option>2x</option>
                                <option selected>4x</option>
                                <option>8x</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-size: 16px;">‡¶¨‡ßç‡¶≤‡ßÅ‡¶Æ ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü</label>
                            <select style="width: 100%; padding: 12px; background: #222; color: white; border: 1px solid #006a4e; border-radius: 8px;">
                                <option>‡¶Ö‡¶´</option>
                                <option selected>‡¶Ö‡¶®</option>
                                <option>‡¶π‡¶æ‡¶á</option>
                            </select>
                        </div>
                    </div>
                </div>
                
                <div style="margin: 20px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 20px; color: #00a8ff;">
                        <i class="fas fa-gamepad"></i> ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏
                    </label>
                    <select id="controlType" style="width: 100%; padding: 15px; background: #111; color: white; border: 2px solid #006a4e; border-radius: 12px; font-size: 18px; margin-bottom: 15px;">
                        <option value="touch" selected>‡¶ü‡¶æ‡¶ö ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤ (‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤)</option>
                        <option value="keyboard">‡¶ï‡ßÄ‡¶¨‡ßã‡¶∞‡ßç‡¶° + ‡¶Æ‡¶æ‡¶â‡¶∏ (‡¶™‡¶ø‡¶∏‡¶ø)</option>
                        <option value="gamepad">‡¶ó‡ßá‡¶Æ‡¶™‡ßç‡¶Ø‡¶æ‡¶°</option>
                        <option value="hybrid">‡¶π‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡¶ø‡¶° ‡¶Æ‡ßã‡¶°</option>
                    </select>
                    
                    <div style="margin-top: 20px;">
                        <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; cursor: pointer;">
                            <input type="checkbox" id="vibration" checked style="width: 20px; height: 20px;">
                            <span>‡¶≠‡¶æ‡¶á‡¶¨‡ßç‡¶∞‡ßá‡¶∂‡¶® ‡¶´‡¶ø‡¶°‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; cursor: pointer;">
                            <input type="checkbox" id="autoRun" checked style="width: 20px; height: 20px;">
                            <span>‡¶Ö‡¶ü‡ßã ‡¶∞‡¶æ‡¶®</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px; cursor: pointer;">
                            <input type="checkbox" id="aimAssist" checked style="width: 20px; height: 20px;">
                            <span>‡¶è‡¶Æ ‡¶è‡¶∏‡¶ø‡¶∏‡ßç‡¶ü</span>
                        </label>
                    </div>
                </div>
                
                <div style="margin: 20px 0; background: rgba(0,0,0,0.3); padding: 20px; border-radius: 15px;">
                    <label style="display: block; margin-bottom: 10px; font-size: 20px; color: #00a8ff;">
                        <i class="fas fa-volume-high"></i> ‡¶Ö‡¶°‡¶ø‡¶ì ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏
                    </label>
                    <div style="margin: 15px 0;">
                        <label style="display: block; margin-bottom: 8px;">‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶ó‡ßç‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶Æ‡¶ø‡¶â‡¶ú‡¶ø‡¶ï</label>
                        <input type="range" min="0" max="100" value="70" style="width: 100%;">
                    </div>
                    <div style="margin: 15px 0;">
                        <label style="display: block; margin-bottom: 8px;">‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶á‡¶´‡ßá‡¶ï‡ßç‡¶ü</label>
                        <input type="range" min="0" max="100" value="90" style="width: 100%;">
                    </div>
                    <div style="margin: 15px 0;">
                        <label style="display: block; margin-bottom: 8px;">‡¶≠‡¶Ø‡¶º‡ßá‡¶∏</label>
                        <input type="range" min="0" max="100" value="80" style="width: 100%;">
                    </div>
                </div>
            </div>
            
            <button class="menu-button" onclick="saveSettings()" style="background: linear-gradient(135deg, #f42a41, #ff6b6b);">
                <i class="fas fa-save"></i> ‡¶∏‡¶¨ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡ßÅ‡¶®
            </button>
        </div>
    </div>

    <!-- MISSIONS MENU -->
    <div id="missionsMenu" class="menu">
        <div class="menu-content">
            <h2><i class="fas fa-flag-checkered"></i> ‡¶Æ‡¶ø‡¶∂‡¶® ‡¶ó‡ßç‡¶Ø‡¶æ‡¶≤‡¶æ‡¶∞‡¶ø</h2>
            <div id="missionsList" style="text-align: left; margin: 25px 0; max-height: 400px; overflow-y: auto; padding-right: 10px;">
                <!-- Missions will be loaded here -->
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                <div style="background: rgba(0,106,78,0.3); padding: 15px; border-radius: 12px; text-align: center;">
                    <div style="color: #ffd700; font-size: 24px; font-weight: bold;">‡ßß‡ß´</div>
                    <div style="color: #ccc; font-size: 14px;">‡¶Æ‡ßã‡¶ü ‡¶Æ‡¶ø‡¶∂‡¶®</div>
                </div>
                <div style="background: rgba(244,42,65,0.3); padding: 15px; border-radius: 12px; text-align: center;">
                    <div style="color: #00ff00; font-size: 24px; font-weight: bold;">‡ß©</div>
                    <div style="color: #ccc; font-size: 14px;">‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶Æ‡¶ø‡¶∂‡¶®</div>
                </div>
            </div>
            <button class="menu-button" id="missionsBackBtn">
                <i class="fas fa-arrow-left-long"></i> ‡¶™‡¶ø‡¶õ‡¶®‡ßá
            </button>
        </div>
    </div>

    <!-- INVENTORY MENU -->
    <div id="inventoryMenu" class="menu">
        <div class="menu-content">
            <h2><i class="fas fa-warehouse"></i> ‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø</h2>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin: 25px 0;">
                <!-- Inventory items will be loaded here -->
            </div>
            <div style="background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; margin: 20px 0;">
                <div style="color: #f42a41; font-size: 18px; margin-bottom: 10px;">‡¶á‡¶®‡¶≠‡ßá‡¶®‡ßç‡¶ü‡¶∞‡¶ø ‡¶∏‡ßç‡¶ü‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∏</div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞:</span>
                    <span style="color: #00a8ff;">‡ß´/‡ßß‡ß¶</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡¶ø‡¶ü:</span>
                    <span style="color: #00ff00;">‡ß©</span>
                </div>
                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                    <span>‡¶Ü‡¶∞‡ßç‡¶Æ‡¶æ‡¶∞:</span>
                    <span style="color: #9b59b6;">‡ß®</span>
                </div>
                <div style="display: flex; justify-content: space-between;">
                    <span>‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ:</span>
                    <span style="color: #ffd700;">‡ß≠</span>
                </div>
            </div>
            <button class="menu-button" id="inventoryBackBtn">
                <i class="fas fa-arrow-left-long"></i> ‡¶™‡¶ø‡¶õ‡¶®‡ßá
            </button>
        </div>
    </div>

    <!-- HELP MENU -->
    <div id="helpMenu" class="menu">
        <div class="menu-content">
            <h2><i class="fas fa-graduation-cap"></i> ‡¶ü‡ßç‡¶∞‡ßá‡¶®‡¶ø‡¶Ç ‡¶Æ‡ßã‡¶°</h2>
            <div style="margin: 25px 0; line-height: 2; text-align: left; max-height: 400px; overflow-y: auto; padding-right: 15px;">
                <div style="background: rgba(0,106,78,0.2); padding: 20px; border-radius: 15px; margin-bottom: 20px;">
                    <div style="color: #f42a41; font-size: 20px; margin-bottom: 15px;">
                        <i class="fas fa-mobile-screen-button"></i> ‡¶Æ‡ßã‡¶¨‡¶æ‡¶á‡¶≤ ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤
                    </div>
                    <div style="display: grid; grid-template-columns: auto 1fr; gap: 15px; align-items: center;">
                        <div style="background: rgba(0,106,78,0.5); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-arrows-up-down-left-right"></i>
                        </div>
                        <div>
                            <div style="color: #00a8ff; font-weight: bold;">‡¶ú‡¶Ø‡¶º‡¶∏‡ßç‡¶ü‡¶ø‡¶ï</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶ö‡¶∞‡¶ø‡¶§‡ßç‡¶∞ ‡¶®‡¶ø‡¶Ø‡¶º‡¶®‡ßç‡¶§‡ßç‡¶∞‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶ö‡¶≤‡¶æ‡¶ö‡¶≤</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #27ae60, #2ecc71); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-up-long"></i>
                        </div>
                        <div>
                            <div style="color: #00ff00; font-weight: bold;">‡¶≤‡¶æ‡¶´‡¶æ‡¶®</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶¨‡¶æ‡¶ß‡¶æ ‡¶Ö‡¶§‡¶ø‡¶ï‡ßç‡¶∞‡¶Æ ‡¶è‡¶¨‡¶Ç ‡¶â‡¶Å‡¶ö‡ßÅ ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡ßá ‡¶â‡¶†‡ßÅ‡¶®</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #c0392b, #e74c3c); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-crosshairs"></i>
                        </div>
                        <div>
                            <div style="color: #ff6b6b; font-weight: bold;">‡¶Ü‡¶ï‡ßç‡¶∞‡¶Æ‡¶£</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶∂‡¶§‡ßç‡¶∞‡ßÅ‡¶¶‡ßá‡¶∞ ‡¶Ü‡¶ï‡ßç‡¶∞‡¶Æ‡¶£ ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #2980b9, #3498db); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-handshake-angle"></i>
                        </div>
                        <div>
                            <div style="color: #74b9ff; font-weight: bold;">‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶ó‡¶æ‡¶°‡¶º‡¶ø, ‡¶¶‡¶∞‡¶ú‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶®‡¶™‡¶ø‡¶∏‡¶ø ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßã‡¶ó‡¶æ‡¶Ø‡ßã‡¶ó</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #e67e22, #f39c12); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-repeat"></i>
                        </div>
                        <div>
                            <div style="color: #fdcb6e; font-weight: bold;">‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞‡ßá‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶∏‡ßç‡¶Ø‡ßÅ‡¶á‡¶ö ‡¶ï‡¶∞‡ßÅ‡¶®</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #8e44ad, #9b59b6); width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px;">
                            <i class="fas fa-gear"></i>
                        </div>
                        <div>
                            <div style="color: #a29bfe; font-weight: bold;">‡¶Æ‡ßá‡¶®‡ßÅ</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶ó‡ßá‡¶Æ ‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶™‡¶∂‡¶®</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(244,42,65,0.1); padding: 20px; border-radius: 15px;">
                    <div style="color: #00a8ff; font-size: 20px; margin-bottom: 15px;">
                        <i class="fas fa-keyboard"></i> ‡¶™‡¶ø‡¶∏‡¶ø ‡¶ï‡¶®‡ßç‡¶ü‡ßç‡¶∞‡ßã‡¶≤
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">W, A, S, D</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶ö‡¶≤‡¶æ‡¶ö‡¶≤</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">Space</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶≤‡¶æ‡¶´‡¶æ‡¶®</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">Shift</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶¶‡ßå‡¶°‡¶º‡¶æ‡¶®</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">Ctrl</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶¨‡¶∏‡ßÅ‡¶®/‡¶∏‡¶æ‡¶Æ‡¶®‡ßá ‡¶π‡ßá‡¶≤‡ßÅ‡¶®</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">F</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶Ü‡¶ï‡ßç‡¶∞‡¶Æ‡¶£/‡¶ó‡ßÅ‡¶≤‡¶ø</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">E</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßá‡¶ï‡ßç‡¶ü</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">1-8</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">ESC</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶™‡¶∏ ‡¶Æ‡ßá‡¶®‡ßÅ</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">Tab</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶Æ‡ßç‡¶Ø‡¶æ‡¶™ ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®</div>
                        </div>
                        <div>
                            <div style="color: #ffd700; font-weight: bold;">M</div>
                            <div style="color: #ccc; font-size: 14px;">‡¶Æ‡¶ø‡¶â‡¶ú‡¶ø‡¶ï ‡¶Ö‡¶®/‡¶Ö‡¶´</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: rgba(0,168,255,0.1); padding: 20px; border-radius: 15px; margin-top: 20px;">
                    <div style="color: #4cd137; font-size: 20px; margin-bottom: 15px;">
                        <i class="fas fa-lightbulb"></i> ‡¶ó‡ßá‡¶Æ‡¶ø‡¶Ç ‡¶ü‡¶ø‡¶™‡¶∏
                    </div>
                    <ul style="color: #ccc; padding-left: 20px;">
                        <li style="margin-bottom: 10px;">üí° ‡¶∞‡¶æ‡¶§‡ßá‡¶∞ ‡¶¨‡ßá‡¶≤‡¶æ ‡¶Ü‡¶≤‡ßã‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶è‡¶≤‡¶æ‡¶ï‡¶æ‡¶Ø‡¶º ‡¶Ø‡¶æ‡¶®, ‡¶¨‡¶ø‡¶™‡¶¶ ‡¶ï‡¶Æ</li>
                        <li style="margin-bottom: 10px;">üí° ‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã‡¶∞ ‡¶∏‡¶Æ‡¶Ø‡¶º ‡¶∏‡ßç‡¶™‡¶ø‡¶° ‡¶≤‡¶ø‡¶Æ‡¶ø‡¶ü ‡¶Æ‡ßá‡¶®‡ßá ‡¶ö‡¶≤‡ßÅ‡¶®</li>
                        <li style="margin-bottom: 10px;">üí° ‡¶¶‡ßã‡¶ï‡¶æ‡¶®‡ßá ‡¶ó‡¶ø‡¶Ø‡¶º‡ßá ‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡¶ø‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶ï‡¶ø‡¶®‡ßÅ‡¶®</li>
                        <li style="margin-bottom: 10px;">üí° ‡¶Æ‡¶ø‡¶∂‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶® ‡¶ï‡¶∞‡ßá ‡¶ü‡¶æ‡¶ï‡¶æ ‡¶è‡¶¨‡¶Ç ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶ø ‡¶Ö‡¶∞‡ßç‡¶ú‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®</li>
                        <li style="margin-bottom: 10px;">üí° ‡¶ó‡ßã‡¶™‡¶® ‡¶ú‡¶æ‡¶Ø‡¶º‡¶ó‡¶æ ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑ ‡¶™‡ßÅ‡¶∞‡¶∏‡ßç‡¶ï‡¶æ‡¶∞ ‡¶™‡¶æ‡¶®</li>
                        <li style="margin-bottom: 10px;">üí° ‡¶è‡¶®‡¶™‡¶ø‡¶∏‡¶ø ‡¶¶‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßá ‡¶§‡¶•‡ßç‡¶Ø ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßÅ‡¶®</li>
                    </ul>
                </div>
            </div>
            <button class="menu-button" id="helpBackBtn">
                <i class="fas fa-arrow-left-long"></i> ‡¶™‡¶ø‡¶õ‡¶®‡ßá
            </button>
        </div>
    </div>

    <!-- DEBUG INFO (Hidden by default) -->
    <div id="debugInfo"></div>

    <!-- THREE.JS LIBRARIES -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/FXAAShader.min.js"></script>

    <!-- CANNON.js Physics -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <!-- TWEEN.js Animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // GAME CONFIGURATION - ULTIMATE EDITION
        const CONFIG = {
            gameName: "NAFIZ EMPIRE",
            version: "2.0.0",
            developer: "Bangladeshi Gaming Studio",
            player: {
                speed: 5.0,
                runSpeed: 8.0,
                jumpForce: 8.0,
                sensitivity: 0.002,
                fov: 75,
                height: 1.7,
                eyeHeight: 1.6
            },
            world: {
                size: 2000,
                buildings: 100,
                trees: 500,
                vehicles: 50,
                npcs: 100,
                detailLevel: 'ultra'
            },
            graphics: {
                shadows: true,
                bloom: true,
                antialiasing: true,
                reflections: true,
                particles: true,
                weatherEffects: true
            }
        };

        // GAME STATE - ADVANCED
        const gameState = {
            isLoaded: false,
            isPaused: false,
            gameStarted: false,
            firstPerson: true,
            debugMode: false,
            player: {
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                armor: 0,
                maxArmor: 100,
                money: 10000,
                score: 2500,
                level: 1,
                experience: 0,
                position: { x: 0, y: 2, z: 0 },
                rotation: { x: 0, y: 0 },
                velocity: { x: 0, y: 0, z: 0 },
                isJumping: false,
                isRunning: false,
                isCrouching: false,
                currentWeapon: 0,
                weapons: [
                    { 
                        name: "‡¶è‡¶Æ-‡ßß‡ß¨ ‡¶∞‡¶æ‡¶á‡¶´‡ßá‡¶≤", 
                        damage: 35, 
                        icon: "fa-gun",
                        ammo: 30,
                        maxAmmo: 120,
                        fireRate: 0.1,
                        range: 100,
                        accuracy: 0.9
                    },
                    { 
                        name: "‡¶è‡¶ï‡ßá-‡ß™‡ß≠", 
                        damage: 30, 
                        icon: "fa-gun",
                        ammo: 30,
                        maxAmmo: 90,
                        fireRate: 0.15,
                        range: 80,
                        accuracy: 0.85
                    },
                    { 
                        name: "‡¶∏‡ßç‡¶®‡¶æ‡¶á‡¶™‡¶æ‡¶∞ ‡¶∞‡¶æ‡¶á‡¶´‡ßá‡¶≤", 
                        damage: 80, 
                        icon: "fa-crosshairs",
                        ammo: 10,
                        maxAmmo: 30,
                        fireRate: 1.5,
                        range: 300,
                        accuracy: 0.95
                    },
                    { 
                        name: "‡¶™‡¶ø‡¶∏‡ßç‡¶§‡¶≤", 
                        damage: 25, 
                        icon: "fa-gun",
                        ammo: 12,
                        maxAmmo: 48,
                        fireRate: 0.3,
                        range: 50,
                        accuracy: 0.8
                    },
                    { 
                        name: "‡¶¨‡ßã‡¶Æ‡¶æ", 
                        damage: 100, 
                        icon: "fa-bomb",
                        ammo: 3,
                        maxAmmo: 9,
                        fireRate: 2.0,
                        range: 20,
                        accuracy: 0.7
                    }
                ],
                inventory: {
                    healthKits: 3,
                    armorKits: 2,
                    grenades: 5,
                    specialItems: []
                },
                inVehicle: false,
                currentVehicle: null,
                wantedLevel: 0
            },
            settings: {
                graphics: 'ultra',
                controls: 'touch',
                sound: true,
                music: true,
                vibration: true,
                autoRun: true,
                aimAssist: true,
                language: 'bn'
            },
            world: {
                time: 11.5,
                isDay: true,
                weather: 'sunny',
                temperature: 28,
                humidity: 65,
                locations: [
                    { name: "‡¶¢‡¶æ‡¶ï‡¶æ ‡¶∏‡ßá‡¶®‡¶æ‡¶®‡¶ø‡¶¨‡¶æ‡¶∏", x: 0, z: 0, type: 'military', importance: 'high' },
                    { name: "‡¶∂‡ßá‡¶ñ ‡¶Æ‡ßÅ‡¶ú‡¶ø‡¶¨‡ßÅ‡¶∞ ‡¶∞‡¶π‡¶Æ‡¶æ‡¶®‡ßá‡¶∞ ‡¶Æ‡ßÇ‡¶∞‡ßç‡¶§‡¶ø", x: 300, z: 200, type: 'monument', importance: 'high' },
                    { name: "‡¶ú‡¶æ‡¶§‡ßÄ‡¶Ø‡¶º ‡¶∏‡¶Ç‡¶∏‡¶¶ ‡¶≠‡¶¨‡¶®", x: -400, z: 100, type: 'government', importance: 'high' },
                    { name: "‡¶≤‡¶æ‡¶≤‡¶¨‡¶æ‡¶ó ‡¶ï‡ßá‡¶≤‡ßç‡¶≤‡¶æ", x: 200, z: -300, type: 'historical', importance: 'medium' },
                    { name: "‡¶Ü‡¶π‡¶∏‡¶æ‡¶® ‡¶Æ‡¶û‡ßç‡¶ú‡¶ø‡¶≤", x: -150, z: 350, type: 'historical', importance: 'medium' },
                    { name: "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂ ‡¶¨‡ßç‡¶Ø‡¶æ‡¶Ç‡¶ï", x: 450, z: -100, type: 'bank', importance: 'high' },
                    { name: "‡¶ö‡¶ü‡ßç‡¶ü‡¶ó‡ßç‡¶∞‡¶æ‡¶Æ ‡¶™‡¶æ‡¶π‡¶æ‡¶°‡¶º", x: 800, z: 800, type: 'nature', importance: 'medium' },
                    { name: "‡¶∏‡ßá‡¶®‡ßç‡¶ü ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ü‡¶ø‡¶® ‡¶¶‡ßç‡¶¨‡ßÄ‡¶™", x: 1200, z: -900, type: 'nature', importance: 'low' },
                    { name: "‡¶∏‡¶ø‡¶≤‡ßá‡¶ü ‡¶ö‡¶æ ‡¶¨‡¶æ‡¶ó‡¶æ‡¶®", x: -700, z: 600, type: 'nature', importance: 'medium' },
                    { name: "‡¶ï‡¶ï‡ßç‡¶∏‡¶¨‡¶æ‡¶ú‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßÅ‡¶¶‡ßç‡¶∞ ‡¶∏‡ßà‡¶ï‡¶§", x: 1000, z: -1200, type: 'nature', importance: 'high' }
                ]
            },
            missions: [
                { 
                    id: 1, 
                    title: "‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶™‡¶¶‡¶ï‡ßç‡¶∑‡ßá‡¶™", 
                    description: "‡¶∂‡¶π‡¶∞‡ßá‡¶∞ ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡¶∏‡ßç‡¶•‡¶≤‡ßá ‡¶Ø‡¶æ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ó‡¶æ‡¶á‡¶°‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßÅ‡¶®",
                    completed: false, 
                    reward: 500, 
                    exp: 100,
                    progress: 0, 
                    target: 1,
                    type: 'tutorial',
                    location: { x: 0, z: 0 }
                },
                { 
                    id: 2, 
                    title: "‡¶ü‡¶æ‡¶ï‡¶æ ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π", 
                    description: "‡ß≥ ‡ß´‡ß¶,‡ß¶‡ß¶‡ß¶ ‡¶ü‡¶æ‡¶ï‡¶æ ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßÅ‡¶® ‡¶¨‡¶ø‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡ßá",
                    completed: false, 
                    reward: 2000, 
                    exp: 250,
                    progress: 0, 
                    target: 50000,
                    type: 'money',
                    location: { x: 450, z: -100 }
                },
                { 
                    id: 3, 
                    title: "‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã", 
                    description: "‡ß´‡¶ü‡¶ø ‡¶≠‡¶ø‡¶®‡ßç‡¶® ‡¶ó‡¶æ‡¶°‡¶º‡¶ø‡¶§‡ßá ‡¶ö‡¶°‡¶º‡ßá ‡¶∂‡¶π‡¶∞ ‡¶ò‡ßÅ‡¶∞‡ßá ‡¶¶‡ßá‡¶ñ‡ßÅ‡¶®",
                    completed: false, 
                    reward: 800, 
                    exp: 150,
                    progress: 0, 
                    target: 5,
                    type: 'vehicle',
                    location: { x: 100, z: -200 }
                },
                { 
                    id: 4, 
                    title: "‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶®‡¶ø‡¶ß‡¶®", 
                    description: "‡ß®‡ß¶‡¶ü‡¶ø ‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶∏‡ßà‡¶®‡ßç‡¶Ø ‡¶®‡¶ø‡¶™‡¶æ‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®",
                    completed: false, 
                    reward: 1500, 
                    exp: 300,
                    progress: 0, 
                    target: 20,
                    type: 'combat',
                    location: { x: 0, z: 0 }
                },
                { 
                    id: 5, 
                    title: "‡¶ê‡¶§‡¶ø‡¶π‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶™‡¶∞‡¶ø‡¶¶‡¶∞‡ßç‡¶∂‡¶®", 
                    description: "‡¶∏‡¶¨ ‡¶ê‡¶§‡¶ø‡¶π‡¶æ‡¶∏‡¶ø‡¶ï ‡¶∏‡ßç‡¶•‡¶æ‡¶® ‡¶≠‡ßç‡¶∞‡¶Æ‡¶£ ‡¶ï‡¶∞‡ßÅ‡¶®",
                    completed: false, 
                    reward: 1200, 
                    exp: 200,
                    progress: 0, 
                    target: 3,
                    type: 'exploration',
                    location: { x: 200, z: -300 }
                }
            ],
            achievements: [
                { id: 1, title: "‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶∞‡¶ï‡ßç‡¶§", description: "‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶¨‡¶ß", unlocked: false },
                { id: 2, title: "‡¶ß‡¶®‡¶ï‡ßÅ‡¶¨‡ßá‡¶∞", description: "‡ß≥ ‡ßß,‡ß¶‡ß¶,‡ß¶‡ß¶‡ß¶ ‡¶ü‡¶æ‡¶ï‡¶æ ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π", unlocked: false },
                { id: 3, title: "‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶™‡ßç‡¶∞‡ßá‡¶Æ‡¶ø‡¶ï", description: "‡ßß‡ß¶‡¶ü‡¶ø ‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶ï‡ßá‡¶®‡¶æ", unlocked: false },
                { id: 4, title: "‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßç‡¶≤‡ßã‡¶∞‡¶æ‡¶∞", description: "‡¶∏‡¶¨ ‡¶≤‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶Æ‡¶æ‡¶∞‡ßç‡¶ï ‡¶Ü‡¶¨‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞", unlocked: false },
                { id: 5, title: "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ", description: "‡ß´‡ß¶‡¶ü‡¶ø ‡¶∏‡¶æ‡¶π‡¶æ‡¶Ø‡ßç‡¶Ø‡ßá‡¶∞ ‡¶ï‡¶æ‡¶ú ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®", unlocked: false }
            ],
            collectibles: [],
            vehicles: [],
            npcs: [],
            buildings: [],
            particles: [],
            projectiles: []
        };

        // THREE.JS VARIABLES
        let scene, camera, renderer, controls, composer;
        let clock, deltaTime;
        let physicsWorld;
        let bloomPass, fxaaPass;
        let playerBody, playerMesh;
        let isPointerLocked = false;

        // INPUT MANAGEMENT
        const keys = {};
        const mouse = { x: 0, y: 0, dx: 0, dy: 0 };
        const touch = {
            joystick: { x: 0, y: 0, active: false },
            look: { x: 0, y: 0, active: false },
            buttons: {}
        };

        // GAME OBJECTS
        const gameObjects = {
            player: null,
            ground: null,
            skybox: null,
            lights: [],
            buildings: [],
            trees: [],
            vehicles: [],
            collectibles: [],
            npcs: [],
            particles: [],
            projectiles: [],
            effects: []
        };

        // TEXTURE LOADER
        const textureLoader = new THREE.TextureLoader();
        const cubeTextureLoader = new THREE.CubeTextureLoader();

        // AUDIO
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioBuffers = {};
        const audioSources = [];

        // PARTICLE SYSTEMS
        const particleSystems = [];

        // LOADING FUNCTIONS
        async function initGame() {
            console.log('üöÄ NAFIZ EMPIRE - Ultimate Bangladeshi Open World Loading...');
            
            // Update loading text and progress
            const loadingText = document.getElementById('loadingText');
            const loadingBar = document.getElementById('loadingBar');
            const tips = [
                "‡¶ó‡ßç‡¶∞‡¶æ‡¶´‡¶ø‡¶ï‡ßç‡¶∏ ‡¶á‡¶û‡ßç‡¶ú‡¶ø‡¶® ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßÄ ‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ö‡¶æ‡¶∞ ‡¶§‡ßà‡¶∞‡¶ø ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶•‡ßç‡¶∞‡¶ø‡¶°‡¶ø ‡¶Æ‡¶°‡ßá‡¶≤ ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶´‡¶ø‡¶ú‡¶ø‡¶ï‡ßç‡¶∏ ‡¶á‡¶û‡ßç‡¶ú‡¶ø‡¶® ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶∏‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶™‡¶æ‡¶∞‡ßç‡¶ü‡¶ø‡¶ï‡ßá‡¶≤ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶≤‡ßã‡¶° ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶è‡¶Ü‡¶á ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶á‡¶®‡¶ø‡¶∂‡¶ø‡¶Ø‡¶º‡¶æ‡¶≤‡¶æ‡¶á‡¶ú‡¶ø‡¶Ç...",
                "‡¶ì‡¶Ø‡¶º‡ßá‡¶¶‡¶æ‡¶∞ ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶≤‡¶æ‡¶á‡¶ü‡¶ø‡¶Ç ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...",
                "‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§! ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! üáßüá©"
            ];
            
            for (let i = 0; i < tips.length; i++) {
                loadingText.textContent = tips[i];
                loadingBar.style.width = ((i + 1) * (100 / tips.length)) + '%';
                await new Promise(resolve => setTimeout(resolve, 400));
            }
            
            // Initialize Three.js with advanced settings
            initAdvancedThreeJS();
            
            // Initialize Physics World
            initPhysicsWorld();
            
            // Create advanced Bangladeshi world
            createAdvancedWorld();
            
            // Create realistic player with first-person view
            createFirstPersonPlayer();
            
            // Create advanced environment
            createAdvancedEnvironment();
            
            // Create Bangladeshi landmarks
            createBangladeshiLandmarks();
            
            // Setup advanced controls
            setupAdvancedControls();
            
            // Setup event listeners
            setupAdvancedEventListeners();
            
            // Initialize audio
            initAudio();
            
            // Initialize particle systems
            initParticleSystems();
            
            // Start game
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    gameState.isLoaded = true;
                    gameState.gameStarted = true;
                    
                    // Show welcome message with Bangladeshi flair
                    showNotification('üáßüá© NAFIZ EMPIRE ‡¶è ‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ! ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶¶‡ßá‡¶∂‡ßá‡¶∞ ‡¶∏‡ßá‡¶∞‡¶æ ‡¶ì‡¶™‡ßá‡¶® ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞‡ßç‡¶≤‡ßç‡¶° ‡¶ó‡ßá‡¶Æ‡¶ø‡¶Ç ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡ßá‡¶∞‡¶ø‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶∏!');
                    
                    // Show first mission
                    setTimeout(() => {
                        showMissionNotification('‡¶™‡ßç‡¶∞‡¶•‡¶Æ ‡¶™‡¶¶‡¶ï‡ßç‡¶∑‡ßá‡¶™', '‡¶∂‡¶π‡¶∞‡ßá‡¶∞ ‡¶ï‡ßá‡¶®‡ßç‡¶¶‡ßç‡¶∞‡¶∏‡ßç‡¶•‡¶≤‡ßá ‡¶Ø‡¶æ‡¶® ‡¶è‡¶¨‡¶Ç ‡¶ó‡¶æ‡¶á‡¶°‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßÅ‡¶®');
                    }, 2000);
                    
                    // Start game loop
                    animate();
                }, 500);
            }, 1000);
        }
        
        function initAdvancedThreeJS() {
            // Create scene with advanced settings
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87ceeb, 100, 2000);
            
            // Create camera with first-person settings
            camera = new THREE.PerspectiveCamera(
                CONFIG.player.fov, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                3000
            );
            camera.position.set(0, CONFIG.player.eyeHeight, 0);
            
            // Create advanced renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = CONFIG.graphics.shadows;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Setup post-processing
            composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Bloom pass for glowing effects
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, 0.4, 0.85
            );
            bloomPass.enabled = CONFIG.graphics.bloom;
            composer.addPass(bloomPass);
            
            // FXAA for anti-aliasing
            fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
            fxaaPass.uniforms['resolution'].value.set(
                1 / window.innerWidth, 
                1 / window.innerHeight
            );
            fxaaPass.enabled = CONFIG.graphics.antialiasing;
            composer.addPass(fxaaPass);
            
            // Add window resize listener
            window.addEventListener('resize', onWindowResize);
            
            // Create clock for delta time
            clock = new THREE.Clock();
            
            // Create pointer lock controls for first-person
            controls = new THREE.PointerLockControls(camera, document.body);
        }
        
        function initPhysicsWorld() {
            // Initialize Cannon.js physics world
            physicsWorld = new CANNON.World();
            physicsWorld.gravity.set(0, -9.82, 0);
            physicsWorld.broadphase = new CANNON.NaiveBroadphase();
            physicsWorld.solver.iterations = 10;
            physicsWorld.defaultContactMaterial.friction = 0.3;
            physicsWorld.defaultContactMaterial.restitution = 0.3;
            
            // Create ground material
            const groundMaterial = new CANNON.Material("ground");
            const playerMaterial = new CANNON.Material("player");
            
            // Contact material between player and ground
            const playerGroundContact = new CANNON.ContactMaterial(
                playerMaterial,
                groundMaterial,
                {
                    friction: 0.5,
                    restitution: 0.3
                }
            );
            physicsWorld.addContactMaterial(playerGroundContact);
        }
        
        function createAdvancedWorld() {
            // Create advanced skybox with Bangladeshi sky
            const skyTextures = [
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/px.jpg',
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/nx.jpg',
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/py.jpg',
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/ny.jpg',
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/pz.jpg',
                'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/nz.jpg'
            ];
            
            const skybox = cubeTextureLoader.load(skyTextures);
            scene.background = skybox;
            
            // Create detailed ground with Bangladeshi terrain
            const groundSize = CONFIG.world.size;
            const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize, 128, 128);
            
            // Create heightmap for terrain variation
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i];
                const z = vertices[i + 2];
                
                // Create hills and valleys
                let height = 0;
                
                // Main hill near center
                const centerDistance = Math.sqrt(x * x + z * z);
                height += Math.max(0, 50 - centerDistance / 10) * Math.random() * 0.5;
                
                // Random smaller hills
                height += Math.sin(x * 0.01) * Math.cos(z * 0.01) * 20;
                height += Math.sin(x * 0.02 + z * 0.015) * 10;
                
                // River beds
                if (Math.abs(z) < 100) {
                    height -= 15;
                }
                
                vertices[i + 1] = height;
            }
            
            groundGeometry.computeVertexNormals();
            
            // Create ground material with Bangladeshi texture
            const groundTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
            groundTexture.repeat.set(32, 32);
            
            const groundMaterial = new THREE.MeshStandardMaterial({
                map: groundTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            
            gameObjects.ground = new THREE.Mesh(groundGeometry, groundMaterial);
            gameObjects.ground.rotation.x = -Math.PI / 2;
            gameObjects.ground.receiveShadow = true;
            gameObjects.ground.castShadow = false;
            scene.add(gameObjects.ground);
            
            // Create physics ground
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ mass: 0 });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            physicsWorld.addBody(groundBody);
            
            // Create roads with Bangladeshi style
            createBangladeshiRoads();
            
            // Create advanced lighting system
            createAdvancedLighting();
        }
        
        function createBangladeshiRoads() {
            const roadMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.9,
                metalness: 0.1
            });
            
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            
            // Create main road network
            const roads = [
                { start: { x: -800, z: 0 }, end: { x: 800, z: 0 }, width: 20 },
                { start: { x: 0, z: -800 }, end: { x: 0, z: 800 }, width: 20 },
                { start: { x: -600, z: -600 }, end: { x: 600, z: 600 }, width: 15 },
                { start: { x: -600, z: 600 }, end: { x: 600, z: -600 }, width: 15 }
            ];
            
            roads.forEach(road => {
                const length = Math.sqrt(
                    Math.pow(road.end.x - road.start.x, 2) + 
                    Math.pow(road.end.z - road.start.z, 2)
                );
                
                const roadGeometry = new THREE.PlaneGeometry(road.width, length);
                const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
                
                // Position and rotate road
                roadMesh.position.set(
                    (road.start.x + road.end.x) / 2,
                    0.1,
                    (road.start.z + road.end.z) / 2
                );
                
                const angle = Math.atan2(road.end.z - road.start.z, road.end.x - road.start.x);
                roadMesh.rotation.y = -angle;
                roadMesh.rotation.x = -Math.PI / 2;
                
                roadMesh.receiveShadow = true;
                scene.add(roadMesh);
                
                // Add road markings
                const segments = Math.floor(length / 30);
                for (let i = -segments/2; i <= segments/2; i++) {
                    if (i % 2 === 0) continue;
                    
                    const lineGeometry = new THREE.PlaneGeometry(1, 5);
                    const lineMesh = new THREE.Mesh(lineGeometry, new THREE.MeshBasicMaterial({ color: 0xffff00 }));
                    
                    lineMesh.position.set(
                        roadMesh.position.x + Math.cos(angle + Math.PI/2) * i * 30 * Math.sin(angle),
                        0.15,
                        roadMesh.position.z + Math.sin(angle + Math.PI/2) * i * 30 * Math.cos(angle)
                    );
                    lineMesh.rotation.x = -Math.PI / 2;
                    lineMesh.rotation.y = -angle;
                    
                    scene.add(lineMesh);
                }
            });
        }
        
        function createAdvancedLighting() {
            // Ambient light for overall illumination
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Main directional light (sun)
            const sunLight = new THREE.DirectionalLight(0xfff4e6, 1.2);
            sunLight.position.set(100, 200, 100);
            sunLight.castShadow = true;
            
            // Advanced shadow settings
            sunLight.shadow.mapSize.width = 4096;
            sunLight.shadow.mapSize.height = 4096;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 2000;
            sunLight.shadow.camera.left = -500;
            sunLight.shadow.camera.right = 500;
            sunLight.shadow.camera.top = 500;
            sunLight.shadow.camera.bottom = -500;
            sunLight.shadow.bias = -0.0001;
            
            scene.add(sunLight);
            
            // Hemisphere light for sky/ground color bleeding
            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x006a4e, 0.4);
            scene.add(hemiLight);
            
            // Fill lights for better illumination
            const fillLight1 = new THREE.DirectionalLight(0x00a8ff, 0.3);
            fillLight1.position.set(-100, 50, -100);
            scene.add(fillLight1);
            
            const fillLight2 = new THREE.DirectionalLight(0xff6b6b, 0.2);
            fillLight2.position.set(100, 50, 100);
            scene.add(fillLight2);
            
            // Point lights for street lights (will be added to buildings)
            const pointLight = new THREE.PointLight(0xffd700, 2, 50);
            pointLight.position.set(0, 10, 0);
            scene.add(pointLight);
            
            gameObjects.lights.push(ambientLight, sunLight, hemiLight, fillLight1, fillLight2, pointLight);
        }
        
        function createFirstPersonPlayer() {
            // Create player physics body (capsule for better collision)
            const playerShape = new CANNON.Cylinder(0.3, 0.3, 1.7, 8);
            playerBody = new CANNON.Body({ 
                mass: 70,
                material: new CANNON.Material({ friction: 0.3 })
            });
            playerBody.addShape(playerShape);
            playerBody.position.set(0, 2, 0);
            playerBody.linearDamping = 0.9;
            playerBody.angularDamping = 0.9;
            physicsWorld.addBody(playerBody);
            
            // Create simple player mesh (not visible in first person, but for shadows)
            const playerGeometry = new THREE.CapsuleGeometry(0.3, 1.4, 4, 8);
            const playerMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf42a41,
                roughness: 0.5,
                metalness: 0.1
            });
            
            playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.castShadow = true;
            playerMesh.receiveShadow = false;
            playerMesh.visible = false; // Hide in first person
            scene.add(playerMesh);
            
            // Add weapon in first person view
            createFirstPersonWeapon();
        }
        
        function createFirstPersonWeapon() {
            // Create weapon model (simplified for first person)
            const weaponGroup = new THREE.Group();
            
            // Rifle body
            const rifleBody = new THREE.BoxGeometry(0.8, 0.15, 0.15);
            const rifleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.7,
                metalness: 0.3
            });
            const rifleMesh = new THREE.Mesh(rifleBody, rifleMaterial);
            rifleMesh.position.set(0.3, -0.2, -0.5);
            weaponGroup.add(rifleMesh);
            
            // Rifle barrel
            const barrel = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
            const barrelMesh = new THREE.Mesh(barrel, new THREE.MeshStandardMaterial({ 
                color: 0x666666,
                roughness: 0.5,
                metalness: 0.5
            }));
            barrelMesh.position.set(0.6, -0.2, -0.5);
            barrelMesh.rotation.z = Math.PI / 2;
            weaponGroup.add(barrelMesh);
            
            // Magazine
            const magazine = new THREE.BoxGeometry(0.2, 0.3, 0.15);
            const magazineMesh = new THREE.Mesh(magazine, new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                roughness: 0.6,
                metalness: 0.2
            }));
            magazineMesh.position.set(0.1, -0.35, -0.5);
            weaponGroup.add(magazineMesh);
            
            // Scope
            const scope = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 16);
            const scopeMesh = new THREE.Mesh(scope, new THREE.MeshStandardMaterial({ 
                color: 0x006a4e,
                roughness: 0.3,
                metalness: 0.7
            }));
            scopeMesh.position.set(0.3, -0.1, -0.5);
            scopeMesh.rotation.z = Math.PI / 2;
            weaponGroup.add(scopeMesh);
            
            weaponGroup.position.set(0.3, -0.2, -0.8);
            camera.add(weaponGroup);
            
            gameObjects.playerWeapon = weaponGroup;
        }
        
        function createAdvancedEnvironment() {
            console.log('Creating advanced Bangladeshi environment...');
            
            // Create detailed Bangladeshi buildings
            for (let i = 0; i < CONFIG.world.buildings; i++) {
                createDetailedBuilding();
            }
            
            // Create realistic trees
            for (let i = 0; i < CONFIG.world.trees; i++) {
                createRealisticTree();
            }
            
            // Create detailed vehicles
            for (let i = 0; i < CONFIG.world.vehicles; i++) {
                createDetailedVehicle();
            }
            
            // Create NPCs with AI
            for (let i = 0; i < CONFIG.world.npcs; i++) {
                createAdvancedNPC();
            }
            
            // Create collectibles
            for (let i = 0; i < 50; i++) {
                createAdvancedCollectible();
            }
            
            // Add water bodies (rivers, ponds)
            createWaterBodies();
            
            // Add vegetation (bushes, grass)
            createVegetation();
            
            // Add street lights and decorations
            createStreetDecorations();
        }
        
        function createDetailedBuilding() {
            // Bangladeshi style buildings with realistic details
            const buildingTypes = [
                { name: 'house', colors: [0x8B4513, 0xA0522D, 0xD2691E], floors: 1 },
                { name: 'apartment', colors: [0x708090, 0x778899, 0x808080], floors: 3 },
                { name: 'shop', colors: [0xDC143C, 0xFF6347, 0xFF7F50], floors: 2 },
                { name: 'office', colors: [0x2F4F4F, 0x4682B4, 0x5F9EA0], floors: 4 },
                { name: 'mosque', colors: [0xFFFFFF, 0xF0F8FF, 0xE6E6FA], floors: 1 }
            ];
            
            const type = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
            const floors = type.floors + Math.floor(Math.random() * 3);
            const width = 8 + Math.random() * 12;
            const depth = 8 + Math.random() * 12;
            const height = floors * 3;
            
            const buildingGroup = new THREE.Group();
            
            // Main building
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshStandardMaterial({
                color: type.colors[Math.floor(Math.random() * type.colors.length)],
                roughness: 0.8,
                metalness: 0.1
            });
            
            const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
            building.castShadow = true;
            building.receiveShadow = true;
            building.position.y = height / 2;
            buildingGroup.add(building);
            
            // Windows
            const windowRows = floors * 2;
            const windowCols = Math.floor(width / 3);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    if (Math.random() > 0.3) {
                        const windowGeometry = new THREE.PlaneGeometry(0.8, 1.2);
                        const windowMaterial = new THREE.MeshBasicMaterial({
                            color: Math.random() > 0.5 ? 0x87CEEB : 0xFFD700,
                            side: THREE.DoubleSide
                        });
                        
                        const window = new THREE.Mesh(windowGeometry, windowMaterial);
                        window.position.set(
                            (col - windowCols/2 + 0.5) * (width / windowCols),
                            (row - windowRows/2 + 0.5) * (height / windowRows) + 0.3,
                            depth/2 + 0.01
                        );
                        
                        // Randomly have some lights on
                        if (Math.random() > 0.7) {
                            const light = new THREE.PointLight(0xFFD700, 0.5, 3);
                            light.position.copy(window.position);
                            light.position.z -= 0.5;
                            buildingGroup.add(light);
                        }
                        
                        buildingGroup.add(window);
                    }
                }
            }
            
            // Roof (Bangladeshi style)
            let roof;
            if (type.name === 'mosque') {
                // Dome for mosque
                roof = new THREE.SphereGeometry(width/2, 16, 16, 0, Math.PI * 2, 0, Math.PI/2);
                const roofMesh = new THREE.Mesh(roof, new THREE.MeshStandardMaterial({ 
                    color: 0x006a4e,
                    roughness: 0.7
                }));
                roofMesh.position.y = height;
                roofMesh.scale.y = 0.5;
                buildingGroup.add(roofMesh);
                
                // Minaret
                const minaret = new THREE.CylinderGeometry(0.5, 0.3, 15, 8);
                const minaretMesh = new THREE.Mesh(minaret, new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.6
                }));
                minaretMesh.position.set(width/2 + 2, 7.5, depth/2 + 2);
                buildingGroup.add(minaretMesh);
            } else {
                // Sloped roof for other buildings
                roof = new THREE.ConeGeometry(width * 0.9, 3, 4);
                const roofMesh = new THREE.Mesh(roof, new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                }));
                roofMesh.position.y = height + 1.5;
                buildingGroup.add(roofMesh);
            }
            
            // Position building away from center
            let x, z;
            do {
                x = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
                z = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
            } while (Math.abs(x) < 100 && Math.abs(z) < 100);
            
            buildingGroup.position.set(x, 0, z);
            buildingGroup.rotation.y = Math.random() * Math.PI * 2;
            
            // Add physics
            const buildingShape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const buildingBody = new CANNON.Body({ mass: 0 });
            buildingBody.addShape(buildingShape);
            buildingBody.position.copy(buildingGroup.position);
            buildingBody.position.y = height/2;
            physicsWorld.addBody(buildingBody);
            
            scene.add(buildingGroup);
            gameObjects.buildings.push({ mesh: buildingGroup, body: buildingBody });
            
            // Add street light near building
            if (Math.random() > 0.7) {
                createStreetLight(x + (Math.random() - 0.5) * 20, z + (Math.random() - 0.5) * 20);
            }
        }
        
        function createRealisticTree() {
            const treeTypes = [
                { name: 'mango', trunkColor: 0x8B4513, leafColor: 0x228B22 },
                { name: 'jackfruit', trunkColor: 0xA0522D, leafColor: 0x32CD32 },
                { name: 'coconut', trunkColor: 0xD2691E, leafColor: 0x90EE90 },
                { name: 'banyan', trunkColor: 0x654321, leafColor: 0x006400 }
            ];
            
            const type = treeTypes[Math.floor(Math.random() * treeTypes.length)];
            const treeGroup = new THREE.Group();
            
            // Trunk with realistic shape
            const trunkHeight = 3 + Math.random() * 5;
            const trunkGeometry = new THREE.CylinderGeometry(
                0.3 + Math.random() * 0.2,
                0.5 + Math.random() * 0.3,
                trunkHeight,
                8
            );
            
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: type.trunkColor,
                roughness: 0.9,
                metalness: 0
            });
            
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);
            
            // Leaves with realistic distribution
            const leafCount = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < leafCount; i++) {
                const leafSize = 2 + Math.random() * 3;
                const leafGeometry = new THREE.SphereGeometry(leafSize, 8, 6);
                const leafMaterial = new THREE.MeshStandardMaterial({
                    color: type.leafColor,
                    roughness: 0.8,
                    metalness: 0
                });
                
                const leaves = new THREE.Mesh(leafGeometry, leafMaterial);
                leaves.position.y = trunkHeight - leafSize/2 + i * leafSize * 0.7;
                leaves.position.x = (Math.random() - 0.5) * leafSize;
                leaves.position.z = (Math.random() - 0.5) * leafSize;
                leaves.castShadow = true;
                leaves.receiveShadow = false;
                
                treeGroup.add(leaves);
            }
            
            // Position tree
            let x, z;
            do {
                x = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
                z = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
            } while (Math.abs(x) < 150 && Math.abs(z) < 150);
            
            treeGroup.position.set(x, 0, z);
            treeGroup.scale.set(0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4);
            
            scene.add(treeGroup);
            gameObjects.trees.push(treeGroup);
        }
        
        function createDetailedVehicle() {
            const vehicleTypes = [
                { 
                    name: 'rickshaw', 
                    colors: [0xf42a41, 0x006a4e, 0x3498db, 0xf1c40f],
                    size: { width: 2, height: 1.8, depth: 3 }
                },
                { 
                    name: 'car', 
                    colors: [0x333333, 0xFFFFFF, 0xC0C0C0, 0x000000],
                    size: { width: 1.8, height: 1.5, depth: 4 }
                },
                { 
                    name: 'bus', 
                    colors: [0x006a4e, 0xf42a41, 0xFFFFFF, 0xFFD700],
                    size: { width: 2.5, height: 3, depth: 8 }
                },
                { 
                    name: 'truck', 
                    colors: [0x8B4513, 0x333333, 0x666666, 0x000000],
                    size: { width: 2.2, height: 2.5, depth: 6 }
                }
            ];
            
            const type = vehicleTypes[Math.floor(Math.random() * vehicleTypes.length)];
            const color = type.colors[Math.floor(Math.random() * type.colors.length)];
            const vehicleGroup = new THREE.Group();
            
            // Main body
            const bodyGeometry = new THREE.BoxGeometry(type.size.width, type.size.height, type.size.depth);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: color,
                roughness: 0.5,
                metalness: 0.2
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = true;
            vehicleGroup.add(body);
            
            // Windows
            const windowGeometry = new THREE.PlaneGeometry(type.size.width * 0.9, type.size.height * 0.4);
            const windowMaterial = new THREE.MeshBasicMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.7
            });
            
            const frontWindow = new THREE.Mesh(windowGeometry, windowMaterial);
            frontWindow.position.set(0, type.size.height * 0.3, type.size.depth/2 - 0.1);
            vehicleGroup.add(frontWindow);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                roughness: 0.8
            });
            
            const wheelPositions = [
                { x: -type.size.width/2 + 0.3, z: type.size.depth/3 },
                { x: type.size.width/2 - 0.3, z: type.size.depth/3 },
                { x: -type.size.width/2 + 0.3, z: -type.size.depth/3 },
                { x: type.size.width/2 - 0.3, z: -type.size.depth/3 }
            ];
            
            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, -type.size.height/2 + 0.3, pos.z);
                wheel.castShadow = true;
                vehicleGroup.add(wheel);
            });
            
            // Additional details based on vehicle type
            if (type.name === 'rickshaw') {
                // Rickshaw canopy
                const canopyGeometry = new THREE.BoxGeometry(type.size.width, 0.5, type.size.depth * 0.8);
                const canopyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.9
                });
                const canopy = new THREE.Mesh(canopyGeometry, canopyMaterial);
                canopy.position.y = type.size.height;
                vehicleGroup.add(canopy);
                
                // Rickshaw decorations
                const decorGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const decorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    roughness: 0.3,
                    metalness: 0.7
                });
                
                for (let i = 0; i < 8; i++) {
                    const decor = new THREE.Mesh(decorGeometry, decorMaterial);
                    decor.position.set(
                        (Math.random() - 0.5) * type.size.width * 0.8,
                        type.size.height + 0.3,
                        (Math.random() - 0.5) * type.size.depth * 0.6
                    );
                    vehicleGroup.add(decor);
                }
            } else if (type.name === 'bus') {
                // Bus windows
                const busWindowGeometry = new THREE.PlaneGeometry(0.8, 0.6);
                for (let i = -3; i <= 3; i++) {
                    const window = new THREE.Mesh(busWindowGeometry, windowMaterial);
                    window.position.set(
                        0,
                        type.size.height * 0.2,
                        i * 0.8
                    );
                    vehicleGroup.add(window);
                }
                
                // Bus sign
                const signGeometry = new THREE.PlaneGeometry(type.size.width * 0.8, 0.4);
                const signMaterial = new THREE.MeshBasicMaterial({ 
                    color: Math.random() > 0.5 ? 0x006a4e : 0xf42a41
                });
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.set(0, type.size.height - 0.2, -type.size.depth/2 + 0.1);
                vehicleGroup.add(sign);
            }
            
            // Position vehicle
            let x, z;
            do {
                x = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
                z = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
            } while (Math.abs(x) < 50 && Math.abs(z) < 50);
            
            vehicleGroup.position.set(x, type.size.height/2, z);
            vehicleGroup.rotation.y = Math.random() * Math.PI * 2;
            
            // Vehicle data
            const vehicleData = {
                mesh: vehicleGroup,
                type: type.name,
                color: color,
                speed: 2 + Math.random() * 5,
                direction: Math.random() * Math.PI * 2,
                userInVehicle: false,
                health: 100
            };
            
            scene.add(vehicleGroup);
            gameObjects.vehicles.push(vehicleData);
        }
        
        function createAdvancedNPC() {
            const npcGroup = new THREE.Group();
            
            // Body
            const bodyGeometry = new THREE.CapsuleGeometry(0.3, 1.4, 4, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.3 ? 0x3498db : 0xe74c3c,
                roughness: 0.6,
                metalness: 0
            });
            
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.castShadow = true;
            body.receiveShadow = false;
            npcGroup.add(body);
            
            // Head with face-like features
            const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0xFFD700,
                roughness: 0.7
            });
            
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.9;
            head.castShadow = true;
            npcGroup.add(head);
            
            // Eyes
            const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.1, 0.95, 0.2);
            npcGroup.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.1, 0.95, 0.2);
            npcGroup.add(rightEye);
            
            // Clothing
            const clothesGeometry = new THREE.CylinderGeometry(0.32, 0.32, 0.5, 8);
            const clothesMaterial = new THREE.MeshStandardMaterial({
                color: Math.random() > 0.5 ? 0x006a4e : 0xf42a41,
                roughness: 0.8
            });
            
            const clothes = new THREE.Mesh(clothesGeometry, clothesMaterial);
            clothes.position.y = 0.3;
            npcGroup.add(clothes);
            
            // Position NPC
            let x, z;
            do {
                x = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
                z = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
            } while (Math.abs(x) < 100 && Math.abs(z) < 100);
            
            npcGroup.position.set(x, 0.9, z);
            
            // NPC data
            const npcData = {
                mesh: npcGroup,
                type: bodyMaterial.color.getHex() === 0xe74c3c ? 'enemy' : 'civilian',
                health: 100,
                speed: 0.5 + Math.random() * 1,
                direction: Math.random() * Math.PI * 2,
                state: 'idle',
                lastStateChange: 0,
                patrolPoints: [],
                awareness: 0,
                aggression: bodyMaterial.color.getHex() === 0xe74c3c ? 0.8 : 0.1
            };
            
            // Add patrol points for NPC
            for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                npcData.patrolPoints.push({
                    x: x + (Math.random() - 0.5) * 50,
                    z: z + (Math.random() - 0.5) * 50
                });
            }
            
            scene.add(npcGroup);
            gameObjects.npcs.push(npcData);
        }
        
        function createAdvancedCollectible() {
            const collectibleTypes = [
                { 
                    type: 'money', 
                    color: 0xFFD700, 
                    value: 100, 
                    icon: 'fa-money-bill',
                    glow: true,
                    spin: true
                },
                { 
                    type: 'health', 
                    color: 0xFF6B6B, 
                    value: 25, 
                    icon: 'fa-heart-pulse',
                    glow: true,
                    pulse: true
                },
                { 
                    type: 'armor', 
                    color: 0x9B59B6, 
                    value: 30, 
                    icon: 'fa-shield-halved',
                    glow: true,
                    spin: true
                },
                { 
                    type: 'ammo', 
                    color: 0x3498DB, 
                    value: 20, 
                    icon: 'fa-bullseye',
                    glow: true
                },
                { 
                    type: 'grenade', 
                    color: 0x2ECC71, 
                    value: 1, 
                    icon: 'fa-bomb',
                    glow: false,
                    spin: true
                }
            ];
            
            const collectibleType = collectibleTypes[Math.floor(Math.random() * collectibleTypes.length)];
            const collectibleGroup = new THREE.Group();
            
            // Main collectible
            const geometry = new THREE.OctahedronGeometry(1, 0);
            const material = new THREE.MeshStandardMaterial({
                color: collectibleType.color,
                emissive: collectibleType.glow ? collectibleType.color : 0x000000,
                emissiveIntensity: collectibleType.glow ? 0.5 : 0,
                roughness: 0.3,
                metalness: 0.7
            });
            
            const collectible = new THREE.Mesh(geometry, material);
            collectible.castShadow = true;
            collectibleGroup.add(collectible);
            
            // Add particle effect
            if (collectibleType.glow) {
                const particleCount = 8;
                const particleGeometry = new THREE.SphereGeometry(0.1, 4, 4);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: collectibleType.color,
                    transparent: true,
                    opacity: 0.6
                });
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 1.5;
                    
                    const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                    particle.position.set(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    );
                    
                    collectibleGroup.add(particle);
                }
            }
            
            // Position collectible
            let x, z;
            do {
                x = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
                z = (Math.random() - 0.5) * (CONFIG.world.size * 0.8);
            } while (Math.abs(x) < 100 && Math.abs(z) < 100);
            
            const y = 2 + Math.random() * 3;
            collectibleGroup.position.set(x, y, z);
            
            // Collectible data
            collectibleGroup.userData = {
                type: collectibleType.type,
                value: collectibleType.value,
                icon: collectibleType.icon,
                originalY: y,
                rotationSpeed: collectibleType.spin ? 0.02 : 0,
                floatSpeed: 0.5 + Math.random() * 0.5,
                floatHeight: 0.5 + Math.random() * 0.5,
                collected: false
            };
            
            scene.add(collectibleGroup);
            gameObjects.collectibles.push(collectibleGroup);
        }
        
        function createBangladeshiLandmarks() {
            console.log('Creating Bangladeshi landmarks...');
            
            // Sheikh Mujibur Rahman Monument
            createMonument(0, 0, 'sheikh_mujib');
            
            // National Parliament Building
            createParliamentBuilding(-400, 100);
            
            // Lalbagh Fort
            createHistoricalFort(200, -300);
            
            // Ahsan Manzil
            createHistoricalBuilding(-150, 350);
            
            // Bangladesh Bank
            createBankBuilding(450, -100);
            
            // Military Base
            createMilitaryBase(0, 0);
        }
        
        function createMonument(x, z, type) {
            const monumentGroup = new THREE.Group();
            
            if (type === 'sheikh_mujib') {
                // Base
                const baseGeometry = new THREE.BoxGeometry(20, 2, 20);
                const baseMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.8
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 1;
                monumentGroup.add(base);
                
                // Monument structure
                const monumentGeometry = new THREE.CylinderGeometry(5, 3, 15, 8);
                const monumentMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.5,
                    metalness: 0.3
                });
                const monument = new THREE.Mesh(monumentGeometry, monumentMaterial);
                monument.position.y = 8.5;
                monumentGroup.add(monument);
                
                // Top decoration
                const topGeometry = new THREE.SphereGeometry(3, 16, 16);
                const topMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    roughness: 0.3,
                    metalness: 0.8
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 16;
                monumentGroup.add(top);
                
                // Flag pole
                const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 10, 8);
                const poleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.4
                });
                const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                pole.position.set(8, 5, 0);
                monumentGroup.add(pole);
                
                // Bangladesh flag
                const flagGeometry = new THREE.PlaneGeometry(6, 3);
                const flagMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x006a4e,
                    side: THREE.DoubleSide
                });
                const flag = new THREE.Mesh(flagGeometry, flagMaterial);
                flag.position.set(8, 5, 1.5);
                flag.rotation.y = Math.PI;
                monumentGroup.add(flag);
                
                // Flag circle
                const circleGeometry = new THREE.CircleGeometry(1, 16);
                const circleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xf42a41
                });
                const circle = new THREE.Mesh(circleGeometry, circleMaterial);
                circle.position.set(8, 5, 1.51);
                circle.rotation.y = Math.PI;
                monumentGroup.add(circle);
            }
            
            monumentGroup.position.set(x, 0, z);
            scene.add(monumentGroup);
            gameObjects.buildings.push({ mesh: monumentGroup, type: 'monument' });
        }
        
        function createParliamentBuilding(x, z) {
            const parliamentGroup = new THREE.Group();
            
            // Main building
            const mainGeometry = new THREE.BoxGeometry(60, 20, 40);
            const mainMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                roughness: 0.6
            });
            const mainBuilding = new THREE.Mesh(mainGeometry, mainMaterial);
            mainBuilding.position.y = 10;
            parliamentGroup.add(mainBuilding);
            
            // Dome
            const domeGeometry = new THREE.SphereGeometry(15, 32, 32, 0, Math.PI * 2, 0, Math.PI/2);
            const domeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006a4e,
                roughness: 0.5
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.y = 25;
            dome.scale.y = 0.5;
            parliamentGroup.add(dome);
            
            // Surrounding lakes
            for (let i = 0; i < 4; i++) {
                const lakeGeometry = new THREE.CircleGeometry(25, 32);
                const lakeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x1E90FF,
                    transparent: true,
                    opacity: 0.7
                });
                const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
                lake.rotation.x = -Math.PI / 2;
                lake.position.y = 0.1;
                
                const angle = (i / 4) * Math.PI * 2;
                lake.position.x = Math.cos(angle) * 45;
                lake.position.z = Math.sin(angle) * 45;
                
                parliamentGroup.add(lake);
            }
            
            parliamentGroup.position.set(x, 0, z);
            scene.add(parliamentGroup);
            gameObjects.buildings.push({ mesh: parliamentGroup, type: 'government' });
        }
        
        function createMilitaryBase(x, z) {
            const baseGroup = new THREE.Group();
            
            // Main barracks
            const barracksGeometry = new THREE.BoxGeometry(40, 10, 60);
            const barracksMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const barracks = new THREE.Mesh(barracksGeometry, barracksMaterial);
            barracks.position.y = 5;
            baseGroup.add(barracks);
            
            // Watch towers
            for (let i = 0; i < 4; i++) {
                const towerGeometry = new THREE.BoxGeometry(4, 15, 4);
                const towerMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    roughness: 0.8
                });
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.y = 7.5;
                
                const angle = (i / 4) * Math.PI * 2;
                tower.position.x = Math.cos(angle) * 35;
                tower.position.z = Math.sin(angle) * 45;
                
                baseGroup.add(tower);
                
                // Tower top
                const topGeometry = new THREE.BoxGeometry(6, 2, 6);
                const top = new THREE.Mesh(topGeometry, towerMaterial);
                top.position.y = 16;
                top.position.x = tower.position.x;
                top.position.z = tower.position.z;
                baseGroup.add(top);
            }
            
            // Army vehicles
            for (let i = 0; i < 6; i++) {
                const vehicleGeometry = new THREE.BoxGeometry(6, 2, 12);
                const vehicleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x006a4e,
                    roughness: 0.7
                });
                const vehicle = new THREE.Mesh(vehicleGeometry, vehicleMaterial);
                vehicle.position.set(
                    -20 + (i % 3) * 20,
                    1,
                    -20 + Math.floor(i / 3) * 20
                );
                baseGroup.add(vehicle);
            }
            
            // Flag pole
            const poleGeometry = new THREE.CylinderGeometry(0.5, 0.5, 25, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFFFFFF,
                roughness: 0.4
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 12.5, -30);
            baseGroup.add(pole);
            
            baseGroup.position.set(x, 0, z);
            scene.add(baseGroup);
            gameObjects.buildings.push({ mesh: baseGroup, type: 'military' });
        }
        
        function createWaterBodies() {
            // Create rivers and ponds
            const waterGeometry = new THREE.PlaneGeometry(1000, 50);
            const waterMaterial = new THREE.MeshBasicMaterial({
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            
            const river = new THREE.Mesh(waterGeometry, waterMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.y = 0.05;
            scene.add(river);
            
            // Create ponds
            for (let i = 0; i < 5; i++) {
                const pondGeometry = new THREE.CircleGeometry(20 + Math.random() * 30, 32);
                const pondMaterial = new THREE.MeshBasicMaterial({
                    color: 0x1E90FF,
                    transparent: true,
                    opacity: 0.7
                });
                
                const pond = new THREE.Mesh(pondGeometry, pondMaterial);
                pond.rotation.x = -Math.PI / 2;
                pond.position.y = 0.06;
                pond.position.x = (Math.random() - 0.5) * 800;
                pond.position.z = (Math.random() - 0.5) * 800;
                
                scene.add(pond);
            }
        }
        
        function createVegetation() {
            // Create grass patches
            const grassGeometry = new THREE.PlaneGeometry(2, 2);
            const grassMaterial = new THREE.MeshBasicMaterial({
                color: 0x32CD32,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            
            for (let i = 0; i < 200; i++) {
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.y = 0.07;
                grass.position.x = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
                grass.position.z = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
                grass.rotation.y = Math.random() * Math.PI;
                
                scene.add(grass);
            }
            
            // Create bushes
            const bushGeometry = new THREE.SphereGeometry(1.5, 8, 8);
            const bushMaterial = new THREE.MeshStandardMaterial({
                color: 0x228B22,
                roughness: 0.9
            });
            
            for (let i = 0; i < 100; i++) {
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.y = 1.5;
                bush.position.x = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
                bush.position.z = (Math.random() - 0.5) * (CONFIG.world.size * 0.9);
                bush.castShadow = true;
                
                scene.add(bush);
            }
        }
        
        function createStreetLight(x, z) {
            const lightGroup = new THREE.Group();
            
            // Pole
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, 8, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x696969,
                roughness: 0.8
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            lightGroup.add(pole);
            
            // Light fixture
            const fixtureGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const fixtureMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8
            });
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.y = 4;
            lightGroup.add(fixture);
            
            // Light source
            const light = new THREE.PointLight(0xFFD700, 1, 20);
            light.position.y = 4;
            lightGroup.add(light);
            
            lightGroup.position.set(x, 0, z);
            scene.add(lightGroup);
        }
        
        function createStreetDecorations() {
            // Create benches
            const benchGeometry = new THREE.BoxGeometry(2, 0.5, 0.8);
            const benchMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            
            for (let i = 0; i < 20; i++) {
                const bench = new THREE.Mesh(benchGeometry, benchMaterial);
                bench.position.y = 0.25;
                bench.position.x = (Math.random() - 0.5) * 800;
                bench.position.z = (Math.random() - 0.5) * 800;
                bench.rotation.y = Math.random() * Math.PI;
                bench.castShadow = true;
                
                scene.add(bench);
            }
            
            // Create street signs
            const signGeometry = new THREE.BoxGeometry(0.1, 2, 0.5);
            const signMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x006a4e,
                roughness: 0.7
            });
            
            for (let i = 0; i < 15; i++) {
                const sign = new THREE.Mesh(signGeometry, signMaterial);
                sign.position.y = 1;
                sign.position.x = (Math.random() - 0.5) * 800;
                sign.position.z = (Math.random() - 0.5) * 800;
                sign.castShadow = true;
                
                scene.add(sign);
            }
        }
        
        function setupAdvancedControls() {
            // Keyboard controls for PC
            document.addEventListener('keydown', (e) => {
                if (gameState.settings.controls === 'keyboard' && gameState.isLoaded && !gameState.isPaused) {
                    keys[e.key.toLowerCase()] = true;
                    
                    // Handle special keys
                    switch(e.key) {
                        case 'Escape':
                            toggleMenu();
                            break;
                        case 'Tab':
                            toggleDebug();
                            break;
                        case '1': case '2': case '3': case '4': case '5':
                            const weaponIndex = parseInt(e.key) - 1;
                            if (weaponIndex < gameState.player.weapons.length) {
                                switchWeapon(weaponIndex);
                            }
                            break;
                        case 'm':
                            toggleMinimap();
                            break;
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                if (gameState.settings.controls === 'keyboard') {
                    keys[e.key.toLowerCase()] = false;
                }
            });
            
            // Mouse movement for first person
            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked && gameState.settings.controls === 'keyboard') {
                    mouse.dx = e.movementX || 0;
                    mouse.dy = e.movementY || 0;
                }
            });
            
            // Mouse click for shooting
            document.addEventListener('mousedown', (e) => {
                if (isPointerLocked && gameState.settings.controls === 'keyboard' && e.button === 0) {
                    performAttack();
                }
            });
            
            // Pointer lock for first person
            document.addEventListener('click', () => {
                if (gameState.settings.controls === 'keyboard' && !gameState.isPaused) {
                    document.body.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });
            
            // Touch joystick for mobile
            setupMobileJoystick();
        }
        
        function setupMobileJoystick() {
            const joystick = document.getElementById('moveJoystick');
            const handle = joystick.querySelector('.joystick-handle');
            
            let joystickActive = false;
            let joystickCenter = { x: 0, y: 0 };
            let joystickRadius = 60;
            
            joystick.addEventListener('touchstart', (e) => {
                if (gameState.settings.controls === 'touch') {
                    const rect = joystick.getBoundingClientRect();
                    joystickCenter.x = rect.left + rect.width / 2;
                    joystickCenter.y = rect.top + rect.height / 2;
                    joystickActive = true;
                    e.preventDefault();
                }
            });
            
            joystick.addEventListener('touchmove', (e) => {
                if (gameState.settings.controls === 'touch' && joystickActive) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickCenter.x;
                    const dy = touch.clientY - joystickCenter.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > joystickRadius) {
                        touch.joystick.x = (dx / distance) * (joystickRadius / 40);
                        touch.joystick.y = (dy / distance) * (joystickRadius / 40);
                        handle.style.transform = `translate(-50%, -50%) translate(${(dx / distance) * 40}px, ${(dy / distance) * 40}px)`;
                    } else {
                        touch.joystick.x = dx / 40;
                        touch.joystick.y = dy / 40;
                        handle.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    }
                    
                    touch.joystick.active = true;
                    e.preventDefault();
                }
            });
            
            joystick.addEventListener('touchend', () => {
                if (gameState.settings.controls === 'touch') {
                    joystickActive = false;
                    touch.joystick.x = 0;
                    touch.joystick.y = 0;
                    touch.joystick.active = false;
                    handle.style.transform = 'translate(-50%, -50%)';
                }
            });
            
            // Look touch area (right side of screen for mobile)
            const lookArea = document.createElement('div');
            lookArea.style.position = 'fixed';
            lookArea.style.top = '0';
            lookArea.style.right = '0';
            lookArea.style.width = '50%';
            lookArea.style.height = '100%';
            lookArea.style.zIndex = '21';
            lookArea.style.pointerEvents = 'auto';
            document.body.appendChild(lookArea);
            
            let lookActive = false;
            let lastTouch = { x: 0, y: 0 };
            
            lookArea.addEventListener('touchstart', (e) => {
                if (gameState.settings.controls === 'touch') {
                    const touch = e.touches[0];
                    lastTouch.x = touch.clientX;
                    lastTouch.y = touch.clientY;
                    lookActive = true;
                    e.preventDefault();
                }
            });
            
            lookArea.addEventListener('touchmove', (e) => {
                if (gameState.settings.controls === 'touch' && lookActive) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - lastTouch.x;
                    const dy = touch.clientY - lastTouch.y;
                    
                    touch.look.x = dx * 0.01;
                    touch.look.y = dy * 0.01;
                    touch.look.active = true;
                    
                    lastTouch.x = touch.clientX;
                    lastTouch.y = touch.clientY;
                    
                    e.preventDefault();
                }
            });
            
            lookArea.addEventListener('touchend', () => {
                if (gameState.settings.controls === 'touch') {
                    lookActive = false;
                    touch.look.x = 0;
                    touch.look.y = 0;
                    touch.look.active = false;
                }
            });
        }
        
        function setupAdvancedEventListeners() {
            // Button event listeners
            document.getElementById('resumeBtn').onclick = () => {
                toggleMenu();
            };
            
            document.getElementById('newGameBtn').onclick = () => {
                if (confirm('‡¶®‡¶§‡ßÅ‡¶® ‡¶ó‡ßá‡¶Æ ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡ßã‡¶ó‡ßç‡¶∞‡ßá‡¶∏ ‡¶®‡¶∑‡ßç‡¶ü ‡¶π‡¶¨‡ßá‡•§')) {
                    location.reload();
                }
            };
            
            document.getElementById('loadGameBtn').onclick = () => {
                loadGame();
            };
            
            document.getElementById('settingsBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'flex';
            };
            
            document.getElementById('missionsBtn').onclick = () => {
                showMissions();
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('missionsMenu').style.display = 'flex';
            };
            
            document.getElementById('inventoryBtn').onclick = () => {
                showInventory();
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('inventoryMenu').style.display = 'flex';
            };
            
            document.getElementById('helpBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('helpMenu').style.display = 'flex';
            };
            
            document.getElementById('backBtn').onclick = () => {
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            
            document.getElementById('missionsBackBtn').onclick = () => {
                document.getElementById('missionsMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            
            document.getElementById('inventoryBackBtn').onclick = () => {
                document.getElementById('inventoryMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            
            document.getElementById('helpBackBtn').onclick = () => {
                document.getElementById('helpMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            
            // Action buttons for mobile
            document.getElementById('jumpBtn').addEventListener('touchstart', () => {
                touch.buttons.jump = true;
            });
            
            document.getElementById('jumpBtn').addEventListener('touchend', () => {
                touch.buttons.jump = false;
            });
            
            document.getElementById('runBtn').addEventListener('touchstart', () => {
                touch.buttons.run = true;
            });
            
            document.getElementById('runBtn').addEventListener('touchend', () => {
                touch.buttons.run = false;
            });
            
            document.getElementById('attackBtn').addEventListener('touchstart', () => {
                touch.buttons.attack = true;
                performAttack();
            });
            
            document.getElementById('weaponBtn').addEventListener('touchstart', () => {
                switchWeapon((gameState.player.currentWeapon + 1) % gameState.player.weapons.length);
            });
            
            document.getElementById('interactBtn').addEventListener('touchstart', () => {
                touch.buttons.interact = true;
                tryInteract();
            });
            
            document.getElementById('menuBtn').addEventListener('touchstart', () => {
                toggleMenu();
            });
            
            // Fullscreen support
            document.addEventListener('dblclick', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });
            
            // Prevent default touch behaviors
            document.addEventListener('touchmove', (e) => {
                if (e.scale !== 1) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function initAudio() {
            // Create audio listener
            const listener = new THREE.AudioListener();
            camera.add(listener);
            
            // Create background music
            const bgMusic = new THREE.Audio(listener);
            gameObjects.bgMusic = bgMusic;
            
            // Create sound effects
            const shootSound = new THREE.Audio(listener);
            const explosionSound = new THREE.Audio(listener);
            const collectSound = new THREE.Audio(listener);
            
            gameObjects.sounds = {
                shoot: shootSound,
                explosion: explosionSound,
                collect: collectSound
            };
        }
        
        function initParticleSystems() {
            // Create particle systems for effects
            const particleCount = 1000;
            
            // Blood particles
            const bloodGeometry = new THREE.BufferGeometry();
            const bloodPositions = new Float32Array(particleCount * 3);
            const bloodColors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                bloodPositions[i * 3] = (Math.random() - 0.5) * 10;
                bloodPositions[i * 3 + 1] = (Math.random() - 0.5) * 10;
                bloodPositions[i * 3 + 2] = (Math.random() - 0.5) * 10;
                
                bloodColors[i * 3] = 0.8 + Math.random() * 0.2; // R
                bloodColors[i * 3 + 1] = 0.1 + Math.random() * 0.1; // G
                bloodColors[i * 3 + 2] = 0.1 + Math.random() * 0.1; // B
            }
            
            bloodGeometry.setAttribute('position', new THREE.BufferAttribute(bloodPositions, 3));
            bloodGeometry.setAttribute('color', new THREE.BufferAttribute(bloodColors, 3));
            
            const bloodMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });
            
            const bloodParticles = new THREE.Points(bloodGeometry, bloodMaterial);
            bloodParticles.visible = false;
            scene.add(bloodParticles);
            
            gameObjects.particleSystems.blood = bloodParticles;
            
            // Smoke particles
            const smokeGeometry = new THREE.BufferGeometry();
            const smokePositions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                smokePositions[i * 3] = (Math.random() - 0.5) * 20;
                smokePositions[i * 3 + 1] = Math.random() * 10;
                smokePositions[i * 3 + 2] = (Math.random() - 0.5) * 20;
            }
            
            smokeGeometry.setAttribute('position', new THREE.BufferAttribute(smokePositions, 3));
            
            const smokeMaterial = new THREE.PointsMaterial({
                size: 0.2,
                color: 0x666666,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const smokeParticles = new THREE.Points(smokeGeometry, smokeMaterial);
            smokeParticles.visible = false;
            scene.add(smokeParticles);
            
            gameObjects.particleSystems.smoke = smokeParticles;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            
            if (fxaaPass) {
                fxaaPass.uniforms['resolution'].value.set(
                    1 / window.innerWidth, 
                    1 / window.innerHeight
                );
            }
        }
        
        // GAME LOGIC FUNCTIONS
        function updatePlayer() {
            if (!gameState.isLoaded || gameState.isPaused) return;
            
            const playerState = gameState.player;
            
            // Handle camera rotation (looking around)
            if (gameState.firstPerson) {
                if (gameState.settings.controls === 'keyboard' && isPointerLocked) {
                    // Mouse look for PC
                    camera.rotation.y -= mouse.dx * CONFIG.player.sensitivity;
                    camera.rotation.x -= mouse.dy * CONFIG.player.sensitivity;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                    
                    mouse.dx = mouse.dy = 0;
                } else if (gameState.settings.controls === 'touch' && touch.look.active) {
                    // Touch look for mobile
                    camera.rotation.y -= touch.look.x * CONFIG.player.sensitivity * 50;
                    camera.rotation.x -= touch.look.y * CONFIG.player.sensitivity * 50;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                }
            }
            
            // Movement input
            let moveX = 0, moveZ = 0;
            
            if (gameState.settings.controls === 'keyboard') {
                if (keys['w'] || keys['arrowup']) moveZ = -1;
                if (keys['s'] || keys['arrowdown']) moveZ = 1;
                if (keys['a'] || keys['arrowleft']) moveX = -1;
                if (keys['d'] || keys['arrowright']) moveX = 1;
                
                playerState.isRunning = keys['shift'] || false;
                touch.buttons.jump = keys[' '] || false;
                touch.buttons.interact = keys['e'] || false;
            } else {
                moveX = touch.joystick.x;
                moveZ = touch.joystick.y;
                playerState.isRunning = touch.buttons.run || false;
            }
            
            // Normalize diagonal movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
            }
            
            // Calculate movement direction relative to camera
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            cameraDirection.y = 0;
            cameraDirection.normalize();
            
            const cameraRight = new THREE.Vector3();
            cameraRight.crossVectors(camera.up, cameraDirection).normalize();
            
            // Calculate final movement vector
            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(cameraDirection, -moveZ);
            moveVector.addScaledVector(cameraRight, moveX);
            moveVector.normalize();
            
            // Apply movement speed
            const speed = playerState.isRunning ? CONFIG.player.runSpeed : CONFIG.player.speed;
            const moveDistance = speed * deltaTime * 60;
            
            // Update player physics body
            if (moveVector.length() > 0) {
                playerBody.velocity.x = moveVector.x * moveDistance * 10;
                playerBody.velocity.z = moveVector.z * moveDistance * 10;
            } else {
                // Apply friction
                playerBody.velocity.x *= 0.9;
                playerBody.velocity.z *= 0.9;
            }
            
            // Jump
            if ((touch.buttons.jump || keys[' ']) && !playerState.isJumping) {
                const ray = new CANNON.Ray(playerBody.position, new CANNON.Vec3(0, -1, 0));
                const result = new CANNON.RaycastResult();
                physicsWorld.rayTest(ray.origin, ray.to(new CANNON.Vec3(0, -2, 0)), result);
                
                if (result.hasHit && result.distance < 1.2) {
                    playerBody.velocity.y = CONFIG.player.jumpForce;
                    playerState.isJumping = true;
                    setTimeout(() => { playerState.isJumping = false; }, 500);
                    touch.buttons.jump = false;
                }
            }
            
            // Update player state from physics
            gameState.player.position.x = playerBody.position.x;
            gameState.player.position.y = playerBody.position.y;
            gameState.player.position.z = playerBody.position.z;
            
            // Update camera position to follow player
            camera.position.x = playerBody.position.x;
            camera.position.y = playerBody.position.y + CONFIG.player.eyeHeight;
            camera.position.z = playerBody.position.z;
            
            // Update player mesh for shadows
            playerMesh.position.copy(playerBody.position);
            playerMesh.position.y += 0.9;
            
            // Stamina management
            if (playerState.isRunning && (moveX !== 0 || moveZ !== 0)) {
                playerState.stamina = Math.max(0, playerState.stamina - 20 * deltaTime);
                if (playerState.stamina === 0) {
                    playerState.isRunning = false;
                }
            } else {
                playerState.stamina = Math.min(playerState.maxStamina, playerState.stamina + 10 * deltaTime);
            }
            
            // Update UI
            updateUI();
            
            // Check collectibles
            checkCollectibles();
            
            // Update NPCs
            updateNPCs();
            
            // Update vehicles
            updateVehicles();
            
            // Update collectible animations
            updateCollectibleAnimations();
            
            // Update particle systems
            updateParticleSystems();
            
            // Update time and weather
            updateTimeAndWeather();
            
            // Update minimap
            updateMinimap();
            
            // Update location display
            updateLocationDisplay();
            
            // Debug info
            if (gameState.debugMode) {
                updateDebugInfo();
            }
        }
        
        function updateNPCs() {
            const currentTime = clock.getElapsedTime();
            const playerPos = gameState.player.position;
            
            gameObjects.npcs.forEach(npc => {
                const mesh = npc.mesh;
                const npcPos = mesh.position;
                
                // State machine for NPC behavior
                switch(npc.state) {
                    case 'idle':
                        // Randomly change to patrol
                        if (currentTime - npc.lastStateChange > 5 + Math.random() * 10) {
                            npc.state = 'patrol';
                            npc.lastStateChange = currentTime;
                        }
                        break;
                        
                    case 'patrol':
                        // Move to next patrol point
                        if (npc.patrolPoints.length > 0) {
                            const target = npc.patrolPoints[0];
                            const dx = target.x - npcPos.x;
                            const dz = target.z - npcPos.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            
                            if (distance < 2) {
                                // Reached point, move to next
                                npc.patrolPoints.shift();
                                if (npc.patrolPoints.length === 0) {
                                    npc.state = 'idle';
                                    npc.lastStateChange = currentTime;
                                }
                            } else {
                                // Move towards point
                                const direction = Math.atan2(dx, dz);
                                npcPos.x += Math.sin(direction) * npc.speed * deltaTime * 60;
                                npcPos.z += Math.cos(direction) * npc.speed * deltaTime * 60;
                                mesh.rotation.y = direction;
                            }
                        }
                        break;
                        
                    case 'chase':
                        // Chase the player if enemy
                        if (npc.type === 'enemy') {
                            const dx = playerPos.x - npcPos.x;
                            const dz = playerPos.z - npcPos.z;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            const direction = Math.atan2(dx, dz);
                            
                            if (distance < 20) {
                                // Move towards player
                                npcPos.x += Math.sin(direction) * npc.speed * 1.5 * deltaTime * 60;
                                npcPos.z += Math.cos(direction) * npc.speed * 1.5 * deltaTime * 60;
                                mesh.rotation.y = direction;
                                
                                // Attack if close enough
                                if (distance < 3 && currentTime - npc.lastStateChange > 1) {
                                    damagePlayer(10);
                                    npc.lastStateChange = currentTime;
                                }
                            } else {
                                // Lost sight of player
                                npc.state = 'search';
                                npc.lastStateChange = currentTime;
                            }
                        }
                        break;
                        
                    case 'search':
                        // Search for player last known position
                        if (currentTime - npc.lastStateChange > 10) {
                            npc.state = 'patrol';
                            npc.lastStateChange = currentTime;
                        }
                        break;
                }
                
                // Check awareness of player
                if (npc.type === 'enemy') {
                    const dx = playerPos.x - npcPos.x;
                    const dz = playerPos.z - npcPos.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);
                    
                    if (distance < 50) {
                        npc.awareness += (50 - distance) * 0.01 * deltaTime;
                    } else {
                        npc.awareness *= 0.99;
                    }
                    
                    if (npc.awareness > 0.5 && npc.state !== 'chase') {
                        npc.state = 'chase';
                        npc.lastStateChange = currentTime;
                    }
                }
                
                // Update NPC position in physics (simple)
                mesh.position.copy(npcPos);
            });
        }
        
        function updateVehicles() {
            gameObjects.vehicles.forEach(vehicle => {
                const mesh = vehicle.mesh;
                
                if (!vehicle.userInVehicle) {
                    // Autonomous vehicle movement
                    vehicle.direction += (Math.random() - 0.5) * 0.1;
                    
                    const moveX = Math.sin(vehicle.direction) * vehicle.speed * deltaTime * 60;
                    const moveZ = Math.cos(vehicle.direction) * vehicle.speed * deltaTime * 60;
                    
                    const newX = mesh.position.x + moveX;
                    const newZ = mesh.position.z + moveZ;
                    
                    // Boundary check
                    if (Math.abs(newX) > CONFIG.world.size * 0.4 || Math.abs(newZ) > CONFIG.world.size * 0.4) {
                        vehicle.direction += Math.PI;
                    } else {
                        mesh.position.x = newX;
                        mesh.position.z = newZ;
                    }
                    
                    mesh.rotation.y = vehicle.direction;
                } else {
                    // Player is driving the vehicle
                    // Vehicle controls would be handled here
                }
            });
        }
        
        function updateCollectibleAnimations() {
            const time = clock.getElapsedTime();
            
            gameObjects.collectibles.forEach(collectible => {
                if (collectible.userData.collected) return;
                
                const data = collectible.userData;
                
                // Float up and down
                collectible.position.y = data.originalY + Math.sin(time * data.floatSpeed) * data.floatHeight;
                
                // Rotate if enabled
                if (data.rotationSpeed > 0) {
                    collectible.rotation.y += data.rotationSpeed;
                }
                
                // Pulse effect for glowing collectibles
                if (collectible.children[0].material.emissiveIntensity > 0) {
                    const pulse = Math.sin(time * 2) * 0.2 + 0.5;
                    collectible.children[0].material.emissiveIntensity = pulse;
                }
            });
        }
        
        function updateParticleSystems() {
            // Update blood particles
            const bloodParticles = gameObjects.particleSystems.blood;
            if (bloodParticles.visible) {
                const positions = bloodParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] -= 0.1; // Gravity
                    positions[i] += (Math.random() - 0.5) * 0.02;
                    positions[i + 2] += (Math.random() - 0.5) * 0.02;
                }
                
                bloodParticles.geometry.attributes.position.needsUpdate = true;
                
                // Fade out
                bloodParticles.material.opacity *= 0.98;
                if (bloodParticles.material.opacity < 0.01) {
                    bloodParticles.visible = false;
                    bloodParticles.material.opacity = 0.8;
                }
            }
            
            // Update smoke particles
            const smokeParticles = gameObjects.particleSystems.smoke;
            if (smokeParticles.visible) {
                const positions = smokeParticles.geometry.attributes.position.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += 0.02; // Rise
                    positions[i] += (Math.random() - 0.5) * 0.01;
                    positions[i + 2] += (Math.random() - 0.5) * 0.01;
                }
                
                smokeParticles.geometry.attributes.position.needsUpdate = true;
                
                // Fade out
                smokeParticles.material.opacity *= 0.995;
                if (smokeParticles.material.opacity < 0.01) {
                    smokeParticles.visible = false;
                    smokeParticles.material.opacity = 0.6;
                }
            }
        }
        
        function updateTimeAndWeather() {
            // Update in-game time
            gameState.world.time += deltaTime * 0.05;
            if (gameState.world.time >= 24) gameState.world.time = 0;
            
            // Update day/night
            gameState.world.isDay = gameState.world.time >= 6 && gameState.world.time < 18;
            
            // Update sun position
            const sunAngle = (gameState.world.time / 24) * Math.PI * 2;
            const sunElevation = Math.sin(sunAngle) * 0.8 + 0.2;
            
            if (gameObjects.lights[1]) { // Sun light
                gameObjects.lights[1].position.x = Math.cos(sunAngle) * 200;
                gameObjects.lights[1].position.y = sunElevation * 200;
                gameObjects.lights[1].position.z = Math.sin(sunAngle) * 200;
                
                // Adjust light intensity based on time
                if (gameState.world.isDay) {
                    gameObjects.lights[1].intensity = sunElevation * 1.2;
                    scene.fog.color.setHex(0x87ceeb);
                } else {
                    gameObjects.lights[1].intensity = 0.1;
                    scene.fog.color.setHex(0x1a237e);
                }
            }
            
            // Update skybox rotation for clouds
            if (gameObjects.skybox) {
                gameObjects.skybox.rotation.y += deltaTime * 0.01;
            }
            
            // Update UI time display
            updateTimeDisplay();
        }
        
        function checkCollectibles() {
            const playerPos = gameState.player.position;
            
            for (let i = gameObjects.collectibles.length - 1; i >= 0; i--) {
                const collectible = gameObjects.collectibles[i];
                if (collectible.userData.collected) continue;
                
                const dx = playerPos.x - collectible.position.x;
                const dz = playerPos.z - collectible.position.z;
                const dy = playerPos.y - collectible.position.y;
                const distance = Math.sqrt(dx * dx + dz * dz + dy * dy);
                
                if (distance < 2) {
                    collectItem(collectible);
                    collectible.userData.collected = true;
                    
                    // Create collection effect
                    createCollectionEffect(collectible.position);
                    
                    // Remove from scene after delay
                    setTimeout(() => {
                        scene.remove(collectible);
                        gameObjects.collectibles.splice(i, 1);
                    }, 500);
                }
            }
        }
        
        function collectItem(collectible) {
            const data = collectible.userData;
            const playerState = gameState.player;
            
            switch(data.type) {
                case 'money':
                    playerState.money += data.value;
                    showNotification(`+‡ß≥${data.value} ‡¶ü‡¶æ‡¶ï‡¶æ ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!`);
                    break;
                    
                case 'health':
                    playerState.health = Math.min(playerState.maxHealth, playerState.health + data.value);
                    showNotification(`+${data.value} ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø ‡¶™‡ßÅ‡¶®‡¶∞‡ßÅ‡¶¶‡ßç‡¶ß‡¶æ‡¶∞!`);
                    break;
                    
                case 'armor':
                    playerState.armor = Math.min(playerState.maxArmor, playerState.armor + data.value);
                    showNotification(`+${data.value} ‡¶Ü‡¶∞‡ßç‡¶Æ‡¶æ‡¶∞ ‡¶∏‡¶Ç‡¶ó‡ßç‡¶∞‡¶π!`);
                    break;
                    
                case 'ammo':
                    const weapon = playerState.weapons[playerState.currentWeapon];
                    weapon.ammo = Math.min(weapon.maxAmmo, weapon.ammo + data.value);
                    showNotification(`+${data.value} ‡¶∞‡¶æ‡¶â‡¶®‡ßç‡¶° ‡¶è‡¶Æ‡ßç‡¶Æ‡ßã!`);
                    break;
                    
                case 'grenade':
                    playerState.inventory.grenades += data.value;
                    showNotification(`+${data.value} ‡¶ó‡ßç‡¶∞‡ßá‡¶®‡ßá‡¶°!`);
                    break;
            }
            
            // Update mission progress
            updateMissionProgress(2, data.value);
            
            // Play collection sound
            if (gameObjects.sounds && gameObjects.sounds.collect) {
                gameObjects.sounds.collect.play();
            }
        }
        
        function createCollectionEffect(position) {
            // Create particle explosion
            const particleCount = 20;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 2;
                
                colors[i * 3] = 1; // R
                colors[i * 3 + 1] = 0.8; // G
                colors[i * 3 + 2] = 0; // B
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const material = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 1
            });
            
            const particles = new THREE.Points(geometry, material);
            particles.position.copy(position);
            scene.add(particles);
            
            // Animate particles
            const startTime = clock.getElapsedTime();
            const animateParticles = () => {
                const currentTime = clock.getElapsedTime();
                const elapsed = currentTime - startTime;
                
                if (elapsed < 1) {
                    const positions = particles.geometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length; i += 3) {
                        positions[i + 1] += 0.1; // Float up
                    }
                    
                    particles.geometry.attributes.position.needsUpdate = true;
                    particles.material.opacity = 1 - elapsed;
                    
                    requestAnimationFrame(animateParticles);
                } else {
                    scene.remove(particles);
                }
            };
            
            animateParticles();
        }
        
        function tryInteract() {
            const playerPos = gameState.player.position;
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            
            // Raycast for interaction
            const raycaster = new THREE.Raycaster(
                camera.position,
                cameraDirection,
                0,
                10
            );
            
            // Check for vehicles
            let closestVehicle = null;
            let closestDistance = Infinity;
            
            gameObjects.vehicles.forEach(vehicle => {
                const distance = playerPos.distanceTo(vehicle.mesh.position);
                if (distance < 10 && distance < closestDistance) {
                    closestDistance = distance;
                    closestVehicle = vehicle;
                }
            });
            
            if (closestVehicle) {
                if (!gameState.player.inVehicle) {
                    // Enter vehicle
                    gameState.player.inVehicle = true;
                    gameState.player.currentVehicle = closestVehicle;
                    closestVehicle.userInVehicle = true;
                    showNotification('‡¶ó‡¶æ‡¶°‡¶º‡¶ø‡¶§‡ßá ‡¶â‡¶†‡¶≤‡ßá‡¶®! ‡¶ö‡¶≤‡¶æ‡¶ö‡¶≤‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ú‡¶Ø‡¶º‡¶∏‡ßç‡¶ü‡¶ø‡¶ï ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®');
                    
                    // Update mission progress
                    updateMissionProgress(3, 1);
                } else {
                    // Exit vehicle
                    gameState.player.inVehicle = false;
                    gameState.player.currentVehicle.userInVehicle = false;
                    gameState.player.currentVehicle = null;
                    showNotification('‡¶ó‡¶æ‡¶°‡¶º‡¶ø ‡¶•‡ßá‡¶ï‡ßá ‡¶®‡¶æ‡¶Æ‡¶≤‡ßá‡¶®');
                }
                
                touch.buttons.interact = false;
                return;
            }
            
            // Check for NPCs to interact with
            gameObjects.npcs.forEach(npc => {
                if (npc.type === 'civilian') {
                    const distance = playerPos.distanceTo(npc.mesh.position);
                    if (distance < 5) {
                        showNotification('‡¶®‡¶æ‡¶ó‡¶∞‡¶ø‡¶ï: "‡¶Ü‡¶∏‡¶∏‡¶æ‡¶≤‡¶æ‡¶Æ‡ßÅ ‡¶Ü‡¶≤‡¶æ‡¶á‡¶ï‡ßÅ‡¶Æ! ‡¶ï‡¶ø‡¶≠‡¶æ‡¶¨‡ßá ‡¶Ü‡¶õ‡ßá‡¶®?"');
                        touch.buttons.interact = false;
                        return;
                    }
                }
            });
            
            showNotification('‡¶ï‡ßã‡¶® ‡¶á‡¶®‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶Ø‡¶æ‡¶ï‡ßç‡¶ü‡ßá‡¶¨‡¶≤ ‡¶¨‡¶∏‡ßç‡¶§‡ßÅ ‡¶®‡ßá‡¶á');
            touch.buttons.interact = false;
        }
        
        function performAttack() {
            if (gameState.isPaused || !gameState.isLoaded) return;
            
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            
            // Check ammo
            if (weapon.ammo <= 0) {
                showNotification('‡¶è‡¶Æ‡ßç‡¶Æ‡ßã ‡¶∂‡ßá‡¶∑! ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®');
                return;
            }
            
            // Use ammo
            weapon.ammo--;
            
            // Show hit effect
            showHitEffect();
            
            // Create muzzle flash
            createMuzzleFlash();
            
            // Play shoot sound
            if (gameObjects.sounds && gameObjects.sounds.shoot) {
                gameObjects.sounds.shoot.play();
            }
            
            // Raycast for hitting targets
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            
            // Check for NPC hits
            let hitNPC = null;
            let hitDistance = Infinity;
            
            gameObjects.npcs.forEach((npc, index) => {
                if (npc.type === 'enemy') {
                    const intersection = raycaster.intersectObject(npc.mesh, true);
                    if (intersection.length > 0) {
                        const distance = intersection[0].distance;
                        if (distance < hitDistance && distance < weapon.range) {
                            hitDistance = distance;
                            hitNPC = { npc, index, point: intersection[0].point };
                        }
                    }
                }
            });
            
            if (hitNPC) {
                // Hit enemy
                hitNPC.npc.health -= weapon.damage;
                
                // Create blood effect
                createBloodEffect(hitNPC.point);
                
                if (hitNPC.npc.health <= 0) {
                    // Enemy defeated
                    showNotification(`‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶®‡¶ø‡¶™‡¶æ‡¶§! +‡ß≥500, +100 ‡¶∏‡ßç‡¶ï‡ßã‡¶∞`);
                    
                    // Remove NPC
                    scene.remove(hitNPC.npc.mesh);
                    gameObjects.npcs.splice(hitNPC.index, 1);
                    
                    // Add rewards
                    gameState.player.money += 500;
                    gameState.player.score += 100;
                    
                    // Update mission progress
                    updateMissionProgress(4, 1);
                    
                    // Check achievements
                    checkAchievement(1); // First Blood
                } else {
                    showNotification(`‡¶∂‡¶§‡ßç‡¶∞‡ßÅ ‡¶ï‡ßç‡¶∑‡¶§‡¶ø‡¶ó‡ßç‡¶∞‡¶∏‡ßç‡¶§!`);
                }
            } else {
                // Miss
                showNotification(`${weapon.name} ‡¶¶‡¶ø‡ßü‡ßá ‡¶ó‡ßÅ‡¶≤‡¶ø ‡¶ö‡¶æ‡¶≤‡¶æ‡¶®‡ßã ‡¶π‡ßü‡ßá‡¶õ‡ßá!`);
            }
            
            // Update UI
            updateWeaponDisplay();
            
            touch.buttons.attack = false;
        }
        
        function createMuzzleFlash() {
            // Create muzzle flash effect
            const flashGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF4500,
                transparent: true,
                opacity: 0.8
            });
            
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flash.position.set(0.6, -0.2, -1);
            camera.add(flash);
            
            // Animate flash
            let opacity = 0.8;
            const animateFlash = () => {
                opacity *= 0.8;
                flash.material.opacity = opacity;
                
                if (opacity > 0.01) {
                    requestAnimationFrame(animateFlash);
                } else {
                    camera.remove(flash);
                }
            };
            
            animateFlash();
        }
        
        function createBloodEffect(position) {
            // Show blood particles
            const bloodParticles = gameObjects.particleSystems.blood;
            bloodParticles.position.copy(position);
            bloodParticles.visible = true;
            bloodParticles.material.opacity = 0.8;
            
            // Reset particle positions
            const positions = bloodParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] = (Math.random() - 0.5) * 2;
                positions[i + 1] = (Math.random() - 0.5) * 2;
                positions[i + 2] = (Math.random() - 0.5) * 2;
            }
            bloodParticles.geometry.attributes.position.needsUpdate = true;
        }
        
        function switchWeapon(index) {
            if (index < gameState.player.weapons.length) {
                gameState.player.currentWeapon = index;
                const weapon = gameState.player.weapons[index];
                showNotification(`‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶®: ${weapon.name}`);
                updateWeaponDisplay();
            }
        }
        
        function damagePlayer(amount) {
            // Apply damage to armor first
            let damageToHealth = amount;
            
            if (gameState.player.armor > 0) {
                const armorDamage = Math.min(gameState.player.armor, amount * 0.7);
                gameState.player.armor -= armorDamage;
                damageToHealth = amount - armorDamage;
            }
            
            // Apply remaining damage to health
            gameState.player.health = Math.max(0, gameState.player.health - damageToHealth);
            
            // Show hit effect
            showHitEffect();
            
            // Play hurt sound
            if (gameObjects.sounds && gameObjects.sounds.explosion) {
                gameObjects.sounds.explosion.play();
            }
            
            // Screen shake
            cameraShake(0.5);
            
            if (gameState.player.health <= 0) {
                gameOver();
            }
        }
        
        function cameraShake(intensity) {
            const originalPosition = camera.position.clone();
            const shakeDuration = 300; // ms
            
            let elapsed = 0;
            const animateShake = () => {
                elapsed += 16; // ~60fps
                const progress = elapsed / shakeDuration;
                
                if (progress < 1) {
                    const shakeAmount = intensity * (1 - progress);
                    camera.position.x = originalPosition.x + (Math.random() - 0.5) * shakeAmount;
                    camera.position.y = originalPosition.y + (Math.random() - 0.5) * shakeAmount;
                    camera.position.z = originalPosition.z + (Math.random() - 0.5) * shakeAmount;
                    
                    requestAnimationFrame(animateShake);
                } else {
                    camera.position.copy(originalPosition);
                }
            };
            
            animateShake();
        }
        
        function gameOver() {
            showNotification('‡¶ó‡ßá‡¶Æ ‡¶ì‡¶≠‡¶æ‡¶∞! ‡¶π‡¶æ‡¶∏‡¶™‡¶æ‡¶§‡¶æ‡¶≤‡ßá ‡¶∏‡ßç‡¶•‡¶æ‡¶®‡¶æ‡¶®‡ßç‡¶§‡¶∞‡¶ø‡¶§ ‡¶π‡¶ö‡ßç‡¶õ‡ßá‡¶®...');
            gameState.isPaused = true;
            
            // Reset player position and health
            setTimeout(() => {
                playerBody.position.set(0, 2, 0);
                playerBody.velocity.set(0, 0, 0);
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.armor = 0;
                gameState.isPaused = false;
                showNotification('‡¶π‡¶æ‡¶∏‡¶™‡¶æ‡¶§‡¶æ‡¶≤ ‡¶•‡ßá‡¶ï‡ßá ‡¶õ‡¶æ‡¶°‡¶º‡¶™‡¶§‡ßç‡¶∞! ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®');
            }, 3000);
        }
        
        // UI FUNCTIONS
        function updateUI() {
            const playerState = gameState.player;
            
            // Update health bar
            const healthPercent = (playerState.health / playerState.maxHealth) * 100;
            document.getElementById('healthBar').style.width = `${healthPercent}%`;
            document.getElementById('healthValue').textContent = `${Math.round(healthPercent)}%`;
            
            // Update stamina bar
            const staminaPercent = (playerState.stamina / playerState.maxStamina) * 100;
            document.getElementById('staminaBar').style.width = `${staminaPercent}%`;
            document.getElementById('staminaValue').textContent = `${Math.round(staminaPercent)}%`;
            
            // Update armor bar
            const armorPercent = (playerState.armor / playerState.maxArmor) * 100;
            document.getElementById('armorBar').style.width = `${armorPercent}%`;
            document.getElementById('armorValue').textContent = `${Math.round(armorPercent)}%`;
            
            // Update money
            document.getElementById('money').textContent = `‡ß≥ ${playerState.money.toLocaleString()}`;
            
            // Update score
            document.getElementById('score').textContent = `${playerState.score.toLocaleString()}`;
            
            // Update weapon display
            updateWeaponDisplay();
        }
        
        function updateWeaponDisplay() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('weaponDisplay').innerHTML = `
                <i class="fas ${weapon.icon}"></i>
                <span id="weaponName">${weapon.name}</span>
                <div id="ammoDisplay">
                    <i class="fas fa-bullseye"></i>
                    <span id="ammoCount">${weapon.ammo}/${weapon.maxAmmo}</span>
                </div>
            `;
        }
        
        function updateTimeDisplay() {
            const hour = Math.floor(gameState.world.time);
            const minute = Math.floor((gameState.world.time % 1) * 60);
            const period = hour < 12 ? '‡¶∏‡¶ï‡¶æ‡¶≤' : hour < 18 ? '‡¶¶‡ßÅ‡¶™‡ßÅ‡¶∞' : '‡¶∞‡¶æ‡¶§';
            
            document.getElementById('timeText').textContent = 
                `${period} ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            // Update time icon
            const timeIcon = document.querySelector('#timeDisplay i');
            if (gameState.world.isDay) {
                timeIcon.className = 'fas fa-sun';
                timeIcon.style.color = '#FFD700';
            } else {
                timeIcon.className = 'fas fa-moon';
                timeIcon.style.color = '#00A8FF';
            }
        }
        
        function updateLocationDisplay() {
            const playerPos = gameState.player.position;
            let closestLocation = gameState.world.locations[0];
            let closestDistance = Infinity;
            
            gameState.world.locations.forEach(location => {
                const dx = playerPos.x - location.x;
                const dz = playerPos.z - location.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestLocation = location;
                }
            });
            
            if (closestDistance < 200) {
                document.getElementById('locationName').textContent = closestLocation.name;
                
                // Update mission progress for exploration
                if (closestDistance < 50 && closestLocation.importance === 'high') {
                    updateMissionProgress(5, 0.2);
                }
            }
        }
        
        function updateMinimap() {
            const playerDot = document.querySelector('.mini-map-player');
            if (!playerDot) return;
            
            const playerPos = gameState.player.position;
            
            // Convert world coordinates to minimap coordinates
            const mapSize = 180; // minimap size in pixels
            const worldSize = CONFIG.world.size * 0.8;
            
            const mapX = (playerPos.x / worldSize) * (mapSize * 0.9) + (mapSize / 2);
            const mapY = (playerPos.z / worldSize) * (mapSize * 0.9) + (mapSize / 2);
            
            playerDot.style.left = `${mapX}px`;
            playerDot.style.top = `${mapY}px`;
            
            // Update NPC dots
            updateNPCDots();
            
            // Update vehicle dots
            updateVehicleDots();
        }
        
        function updateNPCDots() {
            const minimapContent = document.getElementById('miniMapContent');
            const existingNPCDots = minimapContent.querySelectorAll('.mini-map-npc');
            existingNPCDots.forEach(dot => dot.remove());
            
            const playerPos = gameState.player.position;
            const mapSize = 180;
            const worldSize = CONFIG.world.size * 0.8;
            const displayRange = 300; // Only show NPCs within this range
            
            gameObjects.npcs.forEach(npc => {
                const dx = npc.mesh.position.x - playerPos.x;
                const dz = npc.mesh.position.z - playerPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < displayRange) {
                    const mapX = (npc.mesh.position.x / worldSize) * (mapSize * 0.9) + (mapSize / 2);
                    const mapY = (npc.mesh.position.z / worldSize) * (mapSize * 0.9) + (mapSize / 2);
                    
                    const npcDot = document.createElement('div');
                    npcDot.className = 'mini-map-npc';
                    npcDot.style.left = `${mapX}px`;
                    npcDot.style.top = `${mapY}px`;
                    npcDot.style.background = npc.type === 'enemy' ? '#f42a41' : '#3498db';
                    
                    minimapContent.appendChild(npcDot);
                }
            });
        }
        
        function updateVehicleDots() {
            const minimapContent = document.getElementById('miniMapContent');
            const existingVehicleDots = minimapContent.querySelectorAll('.mini-map-vehicle');
            existingVehicleDots.forEach(dot => dot.remove());
            
            const playerPos = gameState.player.position;
            const mapSize = 180;
            const worldSize = CONFIG.world.size * 0.8;
            const displayRange = 400;
            
            gameObjects.vehicles.forEach(vehicle => {
                const dx = vehicle.mesh.position.x - playerPos.x;
                const dz = vehicle.mesh.position.z - playerPos.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < displayRange) {
                    const mapX = (vehicle.mesh.position.x / worldSize) * (mapSize * 0.9) + (mapSize / 2);
                    const mapY = (vehicle.mesh.position.z / worldSize) * (mapSize * 0.9) + (mapSize / 2);
                    
                    const vehicleDot = document.createElement('div');
                    vehicleDot.className = 'mini-map-vehicle';
                    vehicleDot.style.left = `${mapX}px`;
                    vehicleDot.style.top = `${mapY}px`;
                    
                    minimapContent.appendChild(vehicleDot);
                }
            });
        }
        
        function updateMissionProgress(missionId, amount) {
            const mission = gameState.missions.find(m => m.id === missionId);
            if (mission && !mission.completed) {
                mission.progress += amount;
                
                if (mission.progress >= mission.target) {
                    mission.completed = true;
                    mission.progress = mission.target;
                    gameState.player.money += mission.reward;
                    gameState.player.experience += mission.exp;
                    
                    // Level up check
                    if (gameState.player.experience >= gameState.player.level * 100) {
                        gameState.player.level++;
                        gameState.player.experience = 0;
                        showNotification(`‡¶≤‡ßá‡¶≠‡ßá‡¶≤ ‡¶Ü‡¶™! ‡¶è‡¶ñ‡¶® ‡¶≤‡ßá‡¶≠‡ßá‡¶≤ ${gameState.player.level}`);
                    }
                    
                    showNotification(`‡¶Æ‡¶ø‡¶∂‡¶® ‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®! +‡ß≥${mission.reward} ‡¶™‡ßÅ‡¶∞‡¶∏‡ßç‡¶ï‡¶æ‡¶∞`);
                    showAchievementPopup(mission.title);
                }
            }
        }
        
        function checkAchievement(achievementId) {
            const achievement = gameState.achievements.find(a => a.id === achievementId);
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                showAchievementPopup(achievement.title);
            }
        }
        
        function showMissions() {
            const missionsList = document.getElementById('missionsList');
            missionsList.innerHTML = '';
            
            gameState.missions.forEach(mission => {
                const progressPercent = (mission.progress / mission.target) * 100;
                const missionElement = document.createElement('div');
                missionElement.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.4), rgba(20,20,40,0.4))';
                missionElement.style.padding = '20px';
                missionElement.style.margin = '15px 0';
                missionElement.style.borderRadius = '15px';
                missionElement.style.border = '2px solid ' + (mission.completed ? '#00ff00' : '#f42a41');
                missionElement.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
                
                missionElement.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <div style="font-weight: bold; font-size: 18px; color: ${mission.completed ? '#00ff00' : '#f42a41'};">
                            ${mission.title} ${mission.completed ? '‚úì' : ''}
                        </div>
                        <div style="background: ${mission.completed ? '#00ff00' : '#f42a41'}; color: white; padding: 5px 12px; border-radius: 12px; font-size: 14px;">
                            ${mission.type}
                        </div>
                    </div>
                    <div style="font-size: 15px; margin-bottom: 15px; color: #ccc; line-height: 1.5;">
                        ${mission.description}
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1; margin-right: 20px;">
                            <div style="width: 100%; height: 10px; background: #333; border-radius: 5px; overflow: hidden;">
                                <div style="width: ${progressPercent}%; height: 100%; background: ${mission.completed ? '#00ff00' : '#f42a41'};"></div>
                            </div>
                        </div>
                        <div style="font-size: 16px; color: #f1c40f;">
                            ${Math.round(mission.progress)}/${mission.target}
                        </div>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 15px; color: #ccc; font-size: 14px;">
                        <div>
                            <i class="fas fa-money-bill-wave"></i>
                            ‡¶™‡ßÅ‡¶∞‡¶∏‡ßç‡¶ï‡¶æ‡¶∞: ‡ß≥${mission.reward}
                        </div>
                        <div>
                            <i class="fas fa-star"></i>
                            ‡¶è‡¶ï‡ßç‡¶∏‡¶™‡¶ø: ${mission.exp}
                        </div>
                    </div>
                `;
                
                missionsList.appendChild(missionElement);
            });
        }
        
        function showInventory() {
            const inventoryMenu = document.getElementById('inventoryMenu');
            const inventoryGrid = inventoryMenu.querySelector('div[style*="grid-template-columns"]');
            inventoryGrid.innerHTML = '';
            
            // Add weapon slots
            gameState.player.weapons.forEach((weapon, index) => {
                const itemElement = document.createElement('div');
                itemElement.style.background = 'linear-gradient(135deg, rgba(0,0,0,0.5), rgba(40,40,60,0.5))';
                itemElement.style.padding = '15px';
                itemElement.style.borderRadius = '12px';
                itemElement.style.textAlign = 'center';
                itemElement.style.border = index === gameState.player.currentWeapon ? 
                    '2px solid #f42a41' : '1px solid #444';
                itemElement.style.cursor = 'pointer';
                
                itemElement.innerHTML = `
                    <div style="font-size: 36px; color: #f42a41; margin-bottom: 10px;">
                        <i class="fas ${weapon.icon}"></i>
                    </div>
                    <div style="font-weight: bold; margin-bottom: 5px;">${weapon.name}</div>
                    <div style="font-size: 12px; color: #ccc;">
                        ‡¶°‡ßç‡¶Ø‡¶æ‡¶Æ‡ßá‡¶ú: ${weapon.damage}<br>
                        ‡¶è‡¶Æ‡ßç‡¶Æ‡ßã: ${weapon.ammo}/${weapon.maxAmmo}
                    </div>
                `;
                
                itemElement.onclick = () => {
                    switchWeapon(index);
                    showNotification(`‡¶Ö‡¶∏‡ßç‡¶§‡ßç‡¶∞ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü: ${weapon.name}`);
                };
                
                inventoryGrid.appendChild(itemElement);
            });
            
            // Add health kits
            for (let i = 0; i < gameState.player.inventory.healthKits; i++) {
                const itemElement = document.createElement('div');
                itemElement.style.background = 'linear-gradient(135deg, rgba(255,107,107,0.2), rgba(231,76,60,0.2))';
                itemElement.style.padding = '15px';
                itemElement.style.borderRadius = '12px';
                itemElement.style.textAlign = 'center';
                itemElement.style.border = '1px solid #f42a41';
                
                itemElement.innerHTML = `
                    <div style="font-size: 36px; color: #ff6b6b; margin-bottom: 10px;">
                        <i class="fas fa-heart-pulse"></i>
                    </div>
                    <div style="font-weight: bold;">‡¶π‡ßá‡¶≤‡¶• ‡¶ï‡¶ø‡¶ü</div>
                    <div style="font-size: 12px; color: #ccc;">
                        +‡ß®‡ß´ ‡¶∏‡ßç‡¶¨‡¶æ‡¶∏‡ßç‡¶•‡ßç‡¶Ø
                    </div>
                `;
                
                inventoryGrid.appendChild(itemElement);
            }
        }
        
        function showNotification(text, subtitle = '') {
            const notification = document.getElementById('missionNotification');
            const missionText = document.getElementById('missionText');
            
            missionText.textContent = text;
            notification.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        function showMissionNotification(title, text) {
            showNotification(text);
        }
        
        function showAchievementPopup(title) {
            const popup = document.getElementById('achievementPopup');
            const achievementText = document.getElementById('achievementText');
            
            achievementText.textContent = title;
            popup.style.display = 'block';
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                popup.style.display = 'none';
            }, 3000);
        }
        
        function showHitEffect() {
            const hitEffect = document.getElementById('hitEffect');
            hitEffect.style.opacity = '0.8';
            
            setTimeout(() => {
                hitEffect.style.opacity = '0';
            }, 100);
        }
        
        function toggleMenu() {
            gameState.isPaused = !gameState.isPaused;
            const mainMenu = document.getElementById('mainMenu');
            mainMenu.style.display = gameState.isPaused ? 'flex' : 'none';
            
            // Show/hide mobile controls based on pause state
            const mobileControls = document.getElementById('mobileControls');
            mobileControls.style.display = gameState.isPaused ? 'none' : 'flex';
            
            // Release pointer lock when paused
            if (gameState.isPaused && isPointerLocked) {
                document.exitPointerLock();
            }
        }
        
        function toggleDebug() {
            gameState.debugMode = !gameState.debugMode;
            const debugInfo = document.getElementById('debugInfo');
            debugInfo.style.display = gameState.debugMode ? 'block' : 'none';
        }
        
        function toggleMinimap() {
            const minimap = document.getElementById('miniMap');
            minimap.style.display = minimap.style.display === 'none' ? 'block' : 'none';
        }
        
        function saveSettings() {
            const graphicsQuality = document.getElementById('graphicsQuality').value;
            const controlType = document.getElementById('controlType').value;
            
            gameState.settings.graphics = graphicsQuality;
            gameState.settings.controls = controlType;
            
            // Apply graphics settings
            switch(graphicsQuality) {
                case 'low':
                    renderer.setPixelRatio(1);
                    bloomPass.enabled = false;
                    fxaaPass.enabled = false;
                    break;
                case 'medium':
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                    bloomPass.enabled = true;
                    bloomPass.strength = 0.5;
                    fxaaPass.enabled = true;
                    break;
                case 'high':
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    bloomPass.enabled = true;
                    bloomPass.strength = 1.0;
                    fxaaPass.enabled = true;
                    break;
                case 'ultra':
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
                    bloomPass.enabled = true;
                    bloomPass.strength = 1.5;
                    fxaaPass.enabled = true;
                    break;
            }
            
            // Apply control settings
            if (controlType === 'touch') {
                document.getElementById('mobileControls').style.display = 'flex';
            } else {
                document.getElementById('mobileControls').style.display = 'none';
            }
            
            document.getElementById('settingsMenu').style.display = 'none';
            document.getElementById('mainMenu').style.display = 'flex';
            
            showNotification('‡¶∏‡ßá‡¶ü‡¶ø‡¶Ç‡¶∏ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!');
        }
        
        function saveGame() {
            const saveData = {
                player: gameState.player,
                missions: gameState.missions,
                achievements: gameState.achievements,
                timestamp: new Date().toISOString()
            };
            
            localStorage.setItem('nafizEmpireSave', JSON.stringify(saveData));
            showNotification('‡¶ó‡ßá‡¶Æ ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!');
        }
        
        function loadGame() {
            const saveData = localStorage.getItem('nafizEmpireSave');
            if (saveData) {
                const parsed = JSON.parse(saveData);
                
                // Load player data
                gameState.player = { ...gameState.player, ...parsed.player };
                gameState.missions = parsed.missions;
                gameState.achievements = parsed.achievements;
                
                showNotification('‡¶ó‡ßá‡¶Æ ‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá!');
                toggleMenu();
            } else {
                showNotification('‡¶ï‡ßã‡¶® ‡¶∏‡ßá‡¶≠ ‡¶°‡¶æ‡¶ü‡¶æ ‡¶™‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ ‡¶Ø‡¶æ‡¶Ø‡¶º‡¶®‡¶ø!');
            }
        }
        
        function updateDebugInfo() {
            const debugInfo = document.getElementById('debugInfo');
            const player = gameState.player;
            const fps = Math.round(1 / deltaTime);
            
            debugInfo.innerHTML = `
                <div>FPS: ${fps}</div>
                <div>Position: ${player.position.x.toFixed(1)}, ${player.position.y.toFixed(1)}, ${player.position.z.toFixed(1)}</div>
                <div>Health: ${player.health}/${player.maxHealth}</div>
                <div>Stamina: ${player.stamina.toFixed(1)}%</div>
                <div>Money: ‡ß≥${player.money}</div>
                <div>Weapon: ${player.weapons[player.currentWeapon].name}</div>
                <div>In Vehicle: ${player.inVehicle ? 'Yes' : 'No'}</div>
                <div>Time: ${gameState.world.time.toFixed(2)}</div>
                <div>Objects: ${gameObjects.buildings.length} buildings, ${gameObjects.npcs.length} NPCs</div>
            `;
        }
        
        // ANIMATION LOOP
        function animate() {
            requestAnimationFrame(animate);
            
            deltaTime = clock.getDelta();
            
            if (gameState.isLoaded && !gameState.isPaused) {
                // Update physics
                physicsWorld.step(1/60, deltaTime, 3);
                
                // Update game logic
                updatePlayer();
                
                // Update post-processing
                composer.render();
            } else {
                // Still render when paused (for menus)
                renderer.render(scene, camera);
            }
        }
        
        // START THE GAME
        document.addEventListener('DOMContentLoaded', initGame);
        
        // Prevent drag and drop
        document.addEventListener('dragstart', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => e.preventDefault());
        
        // iOS fullscreen support
        if (window.navigator.standalone) {
            document.documentElement.style.height = '100%';
            document.body.style.height = '100%';
        }
    </script>
</body>
</html>
