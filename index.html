<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NAFIZ EMPIRE - Bangladeshi Open World</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* [Keep all the CSS styles from above, they're good] */
        /* ... All previous CSS styles ... */
    </style>
</head>
<body>
    <!-- [Keep all HTML elements from above] -->
    <!-- ... All previous HTML ... -->

    <script>
        // GAME CONFIGURATION - OPTIMIZED
        const CONFIG = {
            gameName: "NAFIZ EMPIRE",
            version: "2.1.0",
            developer: "Bangladeshi Gaming Studio",
            player: {
                speed: 5.0,
                runSpeed: 8.0,
                jumpForce: 8.0,
                sensitivity: 0.002,
                fov: 75,
                height: 1.7,
                eyeHeight: 1.6
            },
            world: {
                size: 1000, // Reduced for performance
                buildings: 30, // Reduced count
                trees: 100, // Reduced count
                vehicles: 20,
                npcs: 30,
                detailLevel: 'medium'
            },
            graphics: {
                shadows: true,
                bloom: false, // Disabled for performance
                antialiasing: false, // Disabled for performance
                reflections: false,
                particles: true,
                weatherEffects: true
            }
        };

        // GAME STATE - SIMPLIFIED
        const gameState = {
            isLoaded: false,
            isPaused: false,
            gameStarted: false,
            firstPerson: true,
            debugMode: false,
            player: {
                health: 100,
                maxHealth: 100,
                stamina: 100,
                maxStamina: 100,
                armor: 0,
                maxArmor: 100,
                money: 10000,
                score: 2500,
                level: 1,
                experience: 0,
                position: { x: 0, y: 2, z: 0 },
                velocity: { x: 0, y: 0, z: 0 },
                isJumping: false,
                isRunning: false,
                currentWeapon: 0,
                weapons: [
                    { 
                        name: "à¦à¦®-à§§à§¬ à¦°à¦¾à¦‡à¦«à§‡à¦²", 
                        damage: 35, 
                        icon: "fa-gun",
                        ammo: 30,
                        maxAmmo: 120
                    },
                    { 
                        name: "à¦ªà¦¿à¦¸à§à¦¤à¦²", 
                        damage: 25, 
                        icon: "fa-gun",
                        ammo: 12,
                        maxAmmo: 48
                    }
                ],
                inventory: {
                    healthKits: 3,
                    armorKits: 2,
                    grenades: 5
                },
                inVehicle: false,
                wantedLevel: 0
            },
            settings: {
                graphics: 'medium',
                controls: 'touch',
                sound: true,
                music: true,
                vibration: true,
                language: 'bn'
            },
            world: {
                time: 11.5,
                isDay: true,
                weather: 'sunny'
            }
        };

        // THREE.JS VARIABLES
        let scene, camera, renderer, controls;
        let clock, deltaTime;
        let physicsWorld;
        let isPointerLocked = false;

        // INPUT MANAGEMENT
        const keys = {};
        const mouse = { x: 0, y: 0, dx: 0, dy: 0 };
        const touch = {
            joystick: { x: 0, y: 0, active: false },
            look: { x: 0, y: 0, active: false },
            buttons: {}
        };

        // OPTIMIZED LOADING SYSTEM
        async function initGame() {
            console.log('ðŸš€ NAFIZ EMPIRE - Optimized Loading...');
            
            const loadingText = document.getElementById('loadingText');
            const loadingBar = document.getElementById('loadingBar');
            
            // Phase 1: Core Engine (10%)
            loadingText.textContent = "à¦•à§‹à¦° à¦‡à¦žà§à¦œà¦¿à¦¨ à¦²à§‹à¦¡ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '10%';
            await delay(100);
            
            // Phase 2: Graphics System (20%)
            loadingText.textContent = "à¦—à§à¦°à¦¾à¦«à¦¿à¦•à§à¦¸ à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦® à¦²à§‹à¦¡ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '20%';
            initThreeJS();
            
            // Phase 3: Physics System (30%)
            loadingText.textContent = "à¦«à¦¿à¦œà¦¿à¦•à§à¦¸ à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦® à¦²à§‹à¦¡ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '30%';
            await delay(100);
            initPhysics();
            
            // Phase 4: World Creation (50%)
            loadingText.textContent = "à¦¬à¦¿à¦¶à§à¦¬ à¦¤à§ˆà¦°à¦¿ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '50%';
            createBasicWorld();
            
            // Phase 5: Player Creation (65%)
            loadingText.textContent = "à¦–à§‡à¦²à§‹à¦¯à¦¼à¦¾à¦¡à¦¼ à¦¤à§ˆà¦°à¦¿ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '65%';
            createPlayer();
            
            // Phase 6: Environment (80%)
            loadingText.textContent = "à¦ªà¦°à¦¿à¦¬à§‡à¦¶ à¦¸à¦¾à¦œà¦¾à¦¨à§‹ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '80%';
            createEnvironment();
            
            // Phase 7: UI Setup (90%)
            loadingText.textContent = "à¦‡à¦‰à¦œà¦¾à¦° à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦«à§‡à¦¸ à¦¸à§‡à¦Ÿà¦¾à¦ª à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '90%';
            setupControls();
            setupEventListeners();
            
            // Phase 8: Complete (100%)
            loadingText.textContent = "à¦ªà§à¦°à¦¸à§à¦¤à§à¦¤! à¦—à§‡à¦® à¦¶à§à¦°à§ à¦¹à¦šà§à¦›à§‡...";
            loadingBar.style.width = '100%';
            
            setTimeout(() => {
                document.getElementById('loadingScreen').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                    gameState.isLoaded = true;
                    gameState.gameStarted = true;
                    
                    showNotification('ðŸ‡§ðŸ‡© NAFIZ EMPIRE à¦ à¦¸à§à¦¬à¦¾à¦—à¦¤à¦®!');
                    startGameLoop();
                }, 500);
            }, 1000);
        }
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        
        function initThreeJS() {
            // Simplified Three.js initialization
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x87ceeb, 100, 1000);
            
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight, 
                0.1, 
                1000
            );
            camera.position.set(0, 1.6, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: false,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap;
            
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            window.addEventListener('resize', onWindowResize);
            clock = new THREE.Clock();
        }
        
        function initPhysics() {
            // Simplified physics
            physicsWorld = {
                gravity: { x: 0, y: -9.8, z: 0 },
                objects: []
            };
        }
        
        function createBasicWorld() {
            // Ground with Bangladeshi texture pattern
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
            const groundMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x3a5f0b, // Green for Bangladeshi fields
                side: THREE.DoubleSide
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Sky with gradient
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x87ceeb,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Sun
            const sunLight = new THREE.DirectionalLight(0xffffff, 1);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
        }
        
        function createPlayer() {
            // Simple player capsule
            const geometry = new THREE.CapsuleGeometry(0.3, 1, 4, 8);
            const material = new THREE.MeshLambertMaterial({ color: 0xf42a41 });
            const player = new THREE.Mesh(geometry, material);
            player.castShadow = true;
            player.position.y = 1;
            scene.add(player);
            
            gameState.player.mesh = player;
            gameState.player.camera = camera;
        }
        
        function createEnvironment() {
            // Create a few Bangladeshi buildings
            createBangladeshiBuilding(50, 0, 50);
            createBangladeshiBuilding(-50, 0, 50);
            createBangladeshiBuilding(50, 0, -50);
            createBangladeshiBuilding(-50, 0, -50);
            
            // Create roads
            createRoad(0, 0, 1000, 20);
            
            // Create some trees
            for (let i = 0; i < 30; i++) {
                createTree(
                    (Math.random() - 0.5) * 800,
                    0,
                    (Math.random() - 0.5) * 800
                );
            }
            
            // Create vehicles
            createVehicle('rickshaw', 30, 0, 30);
            createVehicle('car', -30, 0, 30);
            createVehicle('bus', 0, 0, 100);
            
            // Create water body (pond)
            createPond(200, 0, 200);
            
            // Create field
            createField(-200, 0, -200);
        }
        
        function createBangladeshiBuilding(x, y, z) {
            const group = new THREE.Group();
            
            // Building base
            const baseGeometry = new THREE.BoxGeometry(15, 10, 15);
            const baseMaterial = new THREE.MeshLambertMaterial({ 
                color: Math.random() > 0.5 ? 0x8B4513 : 0xA0522D
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 5;
            base.castShadow = true;
            group.add(base);
            
            // Roof
            const roofGeometry = new THREE.ConeGeometry(10, 4, 4);
            const roofMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B0000
            });
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.y = 12;
            group.add(roof);
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return group;
        }
        
        function createRoad(x, y, z, width) {
            const geometry = new THREE.PlaneGeometry(1000, width);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x333333
            });
            const road = new THREE.Mesh(geometry, material);
            road.rotation.x = -Math.PI / 2;
            road.position.set(x, 0.1, z);
            road.receiveShadow = true;
            scene.add(road);
            
            // Road markings
            for (let i = -5; i <= 5; i++) {
                const lineGeometry = new THREE.PlaneGeometry(2, 0.5);
                const lineMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.rotation.x = -Math.PI / 2;
                line.position.set(i * 50, 0.15, z);
                scene.add(line);
            }
        }
        
        function createTree(x, y, z) {
            const group = new THREE.Group();
            
            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.5, 0.7, 5, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.castShadow = true;
            group.add(trunk);
            
            // Leaves
            const leavesGeometry = new THREE.SphereGeometry(3, 8, 8);
            const leavesMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x228B22
            });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.y = 4;
            leaves.castShadow = true;
            group.add(leaves);
            
            group.position.set(x, y, z);
            scene.add(group);
            
            return group;
        }
        
        function createVehicle(type, x, y, z) {
            const group = new THREE.Group();
            let color;
            
            switch(type) {
                case 'rickshaw':
                    color = 0xff0000;
                    break;
                case 'car':
                    color = 0x0000ff;
                    break;
                case 'bus':
                    color = 0x00ff00;
                    break;
                default:
                    color = 0x888888;
            }
            
            const geometry = new THREE.BoxGeometry(4, 2, 8);
            const material = new THREE.MeshLambertMaterial({ color });
            const vehicle = new THREE.Mesh(geometry, material);
            vehicle.castShadow = true;
            group.add(vehicle);
            
            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8);
            const wheelMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x000000
            });
            
            for (let i = -1; i <= 1; i += 2) {
                for (let j = -1; j <= 1; j += 2) {
                    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(
                        i * 1.5,
                        -1,
                        j * 2.5
                    );
                    group.add(wheel);
                }
            }
            
            group.position.set(x, y + 1, z);
            scene.add(group);
            
            return group;
        }
        
        function createPond(x, y, z) {
            const geometry = new THREE.CircleGeometry(30, 32);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x1E90FF,
                transparent: true,
                opacity: 0.7
            });
            const pond = new THREE.Mesh(geometry, material);
            pond.rotation.x = -Math.PI / 2;
            pond.position.set(x, 0.1, z);
            scene.add(pond);
        }
        
        function createField(x, y, z) {
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x7CFC00
            });
            const field = new THREE.Mesh(geometry, material);
            field.rotation.x = -Math.PI / 2;
            field.position.set(x, 0.05, z);
            scene.add(field);
            
            // Add some crops
            for (let i = 0; i < 20; i++) {
                const cropGeometry = new THREE.BoxGeometry(0.2, 1, 0.2);
                const cropMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x32CD32
                });
                const crop = new THREE.Mesh(cropGeometry, cropMaterial);
                crop.position.set(
                    x + (Math.random() - 0.5) * 80,
                    0.5,
                    z + (Math.random() - 0.5) * 80
                );
                scene.add(crop);
            }
        }
        
        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gameState.isLoaded && !gameState.isPaused) {
                    keys[e.key.toLowerCase()] = true;
                    
                    if (e.key === 'Escape') toggleMenu();
                    if (e.key === ' ') tryJump();
                    if (e.key === 'Shift') gameState.player.isRunning = true;
                    if (e.key === 'f') performAttack();
                    if (e.key === 'e') tryInteract();
                    if (e.key === 'r') switchWeapon();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                if (e.key === 'Shift') gameState.player.isRunning = false;
            });
            
            // Mouse controls
            document.addEventListener('mousemove', (e) => {
                if (isPointerLocked) {
                    mouse.dx = e.movementX || 0;
                    mouse.dy = e.movementY || 0;
                }
            });
            
            document.addEventListener('click', () => {
                if (!gameState.isPaused) {
                    document.body.requestPointerLock();
                }
            });
            
            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });
            
            // Touch controls setup
            setupMobileControls();
        }
        
        function setupMobileControls() {
            const joystick = document.getElementById('moveJoystick');
            const handle = joystick.querySelector('.joystick-handle');
            
            let isJoystickActive = false;
            let joystickStart = { x: 0, y: 0 };
            
            joystick.addEventListener('touchstart', (e) => {
                const rect = joystick.getBoundingClientRect();
                joystickStart.x = rect.left + rect.width / 2;
                joystickStart.y = rect.top + rect.height / 2;
                isJoystickActive = true;
                e.preventDefault();
            });
            
            joystick.addEventListener('touchmove', (e) => {
                if (isJoystickActive) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - joystickStart.x;
                    const dy = touch.clientY - joystickStart.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDistance = 40;
                    
                    if (distance > maxDistance) {
                        touch.joystick.x = (dx / distance);
                        touch.joystick.y = (dy / distance);
                        handle.style.transform = `translate(-50%, -50%) translate(${(dx / distance) * maxDistance}px, ${(dy / distance) * maxDistance}px)`;
                    } else {
                        touch.joystick.x = dx / maxDistance;
                        touch.joystick.y = dy / maxDistance;
                        handle.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px)`;
                    }
                    
                    touch.joystick.active = true;
                    e.preventDefault();
                }
            });
            
            joystick.addEventListener('touchend', () => {
                isJoystickActive = false;
                touch.joystick.x = 0;
                touch.joystick.y = 0;
                touch.joystick.active = false;
                handle.style.transform = 'translate(-50%, -50%)';
            });
            
            // Action buttons
            document.getElementById('jumpBtn').addEventListener('touchstart', tryJump);
            document.getElementById('runBtn').addEventListener('touchstart', () => {
                gameState.player.isRunning = true;
            });
            document.getElementById('runBtn').addEventListener('touchend', () => {
                gameState.player.isRunning = false;
            });
            document.getElementById('attackBtn').addEventListener('touchstart', performAttack);
            document.getElementById('weaponBtn').addEventListener('touchstart', switchWeapon);
            document.getElementById('interactBtn').addEventListener('touchstart', tryInteract);
            document.getElementById('menuBtn').addEventListener('touchstart', toggleMenu);
        }
        
        function setupEventListeners() {
            // Menu buttons
            document.getElementById('resumeBtn').onclick = toggleMenu;
            document.getElementById('newGameBtn').onclick = () => {
                if (confirm('à¦¨à¦¤à§à¦¨ à¦—à§‡à¦® à¦¶à§à¦°à§ à¦•à¦°à¦¤à§‡ à¦šà¦¾à¦¨?')) {
                    location.reload();
                }
            };
            document.getElementById('backBtn').onclick = () => {
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            document.getElementById('missionsBackBtn').onclick = () => {
                document.getElementById('missionsMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            document.getElementById('inventoryBackBtn').onclick = () => {
                document.getElementById('inventoryMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            document.getElementById('helpBackBtn').onclick = () => {
                document.getElementById('helpMenu').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'flex';
            };
            
            document.getElementById('settingsBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'flex';
            };
            document.getElementById('missionsBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('missionsMenu').style.display = 'flex';
            };
            document.getElementById('inventoryBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('inventoryMenu').style.display = 'flex';
            };
            document.getElementById('helpBtn').onclick = () => {
                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('helpMenu').style.display = 'flex';
            };
            
            // Fullscreen support
            document.addEventListener('dblclick', toggleFullscreen);
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // GAME LOGIC FUNCTIONS
        function updatePlayer() {
            if (!gameState.isLoaded || gameState.isPaused) return;
            
            const player = gameState.player;
            
            // Camera rotation
            if (isPointerLocked) {
                camera.rotation.y -= mouse.dx * 0.002;
                camera.rotation.x -= mouse.dy * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                mouse.dx = mouse.dy = 0;
            }
            
            // Movement
            let moveX = 0, moveZ = 0;
            
            if (keys['w'] || keys['arrowup']) moveZ = -1;
            if (keys['s'] || keys['arrowdown']) moveZ = 1;
            if (keys['a'] || keys['arrowleft']) moveX = -1;
            if (keys['d'] || keys['arrowright']) moveX = 1;
            
            // Mobile joystick
            if (touch.joystick.active) {
                moveX = touch.joystick.x;
                moveZ = touch.joystick.y;
            }
            
            // Normalize movement
            if (moveX !== 0 || moveZ !== 0) {
                const length = Math.sqrt(moveX * moveX + moveZ * moveZ);
                moveX /= length;
                moveZ /= length;
            }
            
            // Apply movement
            const speed = player.isRunning ? 8 : 5;
            const moveDistance = speed * deltaTime;
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();
            
            const right = new THREE.Vector3();
            right.crossVectors(camera.up, direction).normalize();
            
            const moveVector = new THREE.Vector3();
            moveVector.addScaledVector(direction, -moveZ);
            moveVector.addScaledVector(right, moveX);
            moveVector.normalize();
            
            if (player.mesh) {
                player.mesh.position.x += moveVector.x * moveDistance;
                player.mesh.position.z += moveVector.z * moveDistance;
                
                // Update camera position
                camera.position.x = player.mesh.position.x;
                camera.position.y = player.mesh.position.y + 1.6;
                camera.position.z = player.mesh.position.z;
                
                // Update game state
                player.position.x = player.mesh.position.x;
                player.position.y = player.mesh.position.y;
                player.position.z = player.mesh.position.z;
            }
            
            // Stamina management
            if (player.isRunning && (moveX !== 0 || moveZ !== 0)) {
                player.stamina = Math.max(0, player.stamina - 20 * deltaTime);
                if (player.stamina === 0) {
                    player.isRunning = false;
                }
            } else {
                player.stamina = Math.min(player.maxStamina, player.stamina + 10 * deltaTime);
            }
            
            // Update UI
            updateUI();
            updateMinimap();
            updateTimeDisplay();
        }
        
        function tryJump() {
            if (!gameState.player.isJumping) {
                gameState.player.isJumping = true;
                if (gameState.player.mesh) {
                    gameState.player.mesh.position.y += 1;
                }
                setTimeout(() => {
                    gameState.player.isJumping = false;
                }, 500);
            }
        }
        
        function performAttack() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            
            if (weapon.ammo > 0) {
                weapon.ammo--;
                showHitEffect();
                showNotification(`${weapon.name} à¦¦à¦¿à§Ÿà§‡ à¦—à§à¦²à¦¿ à¦šà¦¾à¦²à¦¾à¦¨à§‹ à¦¹à§Ÿà§‡à¦›à§‡!`);
                updateWeaponDisplay();
                
                // Create bullet tracer
                createBulletTracer();
            } else {
                showNotification('à¦à¦®à§à¦®à§‹ à¦¶à§‡à¦·!');
            }
        }
        
        function createBulletTracer() {
            const geometry = new THREE.CylinderGeometry(0.05, 0.05, 10, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const tracer = new THREE.Mesh(geometry, material);
            
            tracer.position.copy(camera.position);
            tracer.rotation.copy(camera.rotation);
            tracer.translateZ(-5);
            
            scene.add(tracer);
            
            // Remove after short time
            setTimeout(() => {
                scene.remove(tracer);
            }, 100);
        }
        
        function switchWeapon() {
            gameState.player.currentWeapon = (gameState.player.currentWeapon + 1) % gameState.player.weapons.length;
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            showNotification(`à¦…à¦¸à§à¦¤à§à¦° à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¨: ${weapon.name}`);
            updateWeaponDisplay();
        }
        
        function tryInteract() {
            showNotification('à¦‡à¦¨à§à¦Ÿà¦¾à¦°à§à¦¯à¦¾à¦•à§à¦Ÿ à¦¬à¦¾à¦Ÿà¦¨ à¦šà¦¾à¦ªà¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡!');
        }
        
        // UI FUNCTIONS
        function updateUI() {
            const player = gameState.player;
            
            // Health
            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('healthBar').style.width = `${healthPercent}%`;
            document.getElementById('healthValue').textContent = `${Math.round(healthPercent)}%`;
            
            // Stamina
            const staminaPercent = (player.stamina / player.maxStamina) * 100;
            document.getElementById('staminaBar').style.width = `${staminaPercent}%`;
            document.getElementById('staminaValue').textContent = `${Math.round(staminaPercent)}%`;
            
            // Money
            document.getElementById('money').textContent = `à§³ ${player.money.toLocaleString()}`;
            
            // Score
            document.getElementById('score').textContent = player.score.toLocaleString();
        }
        
        function updateWeaponDisplay() {
            const weapon = gameState.player.weapons[gameState.player.currentWeapon];
            document.getElementById('weaponName').textContent = weapon.name;
            document.getElementById('ammoCount').textContent = `${weapon.ammo}/${weapon.maxAmmo}`;
        }
        
        function updateTimeDisplay() {
            gameState.world.time += deltaTime * 0.01;
            if (gameState.world.time >= 24) gameState.world.time = 0;
            
            const hour = Math.floor(gameState.world.time);
            const minute = Math.floor((gameState.world.time % 1) * 60);
            const period = hour < 12 ? 'à¦¸à¦•à¦¾à¦²' : hour < 18 ? 'à¦¦à§à¦ªà§à¦°' : 'à¦°à¦¾à¦¤';
            
            document.getElementById('timeText').textContent = 
                `${period} ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
            
            // Update sun position
            const sunAngle = (gameState.world.time / 24) * Math.PI * 2;
            const sun = scene.getObjectByProperty('type', 'DirectionalLight');
            if (sun) {
                sun.position.x = Math.cos(sunAngle) * 100;
                sun.position.y = Math.sin(sunAngle) * 100;
            }
        }
        
        function updateMinimap() {
            const playerDot = document.querySelector('.mini-map-player');
            if (!playerDot || !gameState.player.mesh) return;
            
            const player = gameState.player;
            const mapSize = 180;
            const worldSize = 1000;
            
            const mapX = (player.position.x / worldSize) * (mapSize * 0.9) + (mapSize / 2);
            const mapY = (player.position.z / worldSize) * (mapSize * 0.9) + (mapSize / 2);
            
            playerDot.style.left = `${mapX}px`;
            playerDot.style.top = `${mapY}px`;
        }
        
        function showNotification(text) {
            const notification = document.getElementById('missionNotification');
            const missionText = document.getElementById('missionText');
            
            missionText.textContent = text;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }
        
        function showHitEffect() {
            const hitEffect = document.getElementById('hitEffect');
            hitEffect.style.opacity = '0.8';
            
            setTimeout(() => {
                hitEffect.style.opacity = '0';
            }, 100);
        }
        
        function toggleMenu() {
            gameState.isPaused = !gameState.isPaused;
            const mainMenu = document.getElementById('mainMenu');
            mainMenu.style.display = gameState.isPaused ? 'flex' : 'none';
            
            const mobileControls = document.getElementById('mobileControls');
            mobileControls.style.display = gameState.isPaused ? 'none' : 'flex';
            
            if (gameState.isPaused && isPointerLocked) {
                document.exitPointerLock();
            }
        }
        
        // GAME LOOP
        function startGameLoop() {
            function animate() {
                requestAnimationFrame(animate);
                deltaTime = clock.getDelta();
                
                if (gameState.isLoaded && !gameState.isPaused) {
                    updatePlayer();
                    renderer.render(scene, camera);
                }
            }
            animate();
        }
        
        // START THE GAME
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(initGame, 500); // Small delay to ensure everything is ready
        });
        
        // Prevent default behaviors
        document.addEventListener('touchmove', (e) => {
            if (e.scale !== 1) e.preventDefault();
        }, { passive: false });
        
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // iOS fullscreen support
        if (window.navigator.standalone) {
            document.documentElement.style.height = '100%';
            document.body.style.height = '100%';
        }
    </script>
    
    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</body>
</html>
